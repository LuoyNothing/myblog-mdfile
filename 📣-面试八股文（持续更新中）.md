---
title: 📣-面试八股文-html-css-js（持续更新中）
date: 2023-09-03 16:44:25
categories: 八股文
tags: ['html~css~js', '持续更新中']
comments: true
---

<meta name="referrer" content="no-referrer"/>

# 📚 html 和 h5

## 1. h5新增了哪些新特性√

1. 语义化标签，例如header，footer，section，article等 语义化标签的作用：提升页面的阅读性(结构性增强)，更有利于SEO，对于使用屏幕阅读器的人来说会更友好(有明显的语气差别，例如strong标签内的内容会重读)；还新增了一些状态标签、列表标签、文本标签。
2. 新增媒体元素，audio、video标签能够很容易的输出音频或视频流，提供便利的获取文件信息的API
3. 新增的表单控件：calendar、date、time、email、url、search 
4. 用于绘画的canvas属性 Canvas API 提供了一个通过JavaScript 和 HTML的**canvas**元素来绘制图形的方式。它可以用于动画、游戏画面、数据可视化、图片编辑以及实时视频处理等方面。
5. 新增本地存储方式：sessionStorage、localStorage sessionStorage 用于存储会话级别的数据，会话关闭，数据消失，不可设置过期时间。
    localStorage 用于存储需要进行持久化存储的数据，只要不主动删除，数据不会消失。
6. 新的技术：webworker、websocket webworker：用于多线程编程
   websocket：客户端与服务端双向数据通信协议

## 2.localstorage、sessionstorage可以跨域吗，cookie有哪些属性√

本地存储和会话存储都存储键值对。

**本地存储和会话存储的主要区别在于**，**在关闭浏览器后**，**存储在会话存储中的键值对会丢失**。下面是基本的使用（两者API一样，这里列举的是会话存储）：

```
// 保存键值对、获取键值对
sessionStorage.setItem('Name1', 'uiu');
sessionStorage.getItem('Name1');

// 保存数组，获取数据，如果不用JSON.parse()，则得到的是字符串
let ProgrammingLanguage = ['Java', 'Python', 'JavaScript', 'GO+']
sessionStorage.setItem('favoriteProgrammingLanguage',JSON.stringify(ProgrammingLanguage));
console.log(JSON.parse(sessionStorage.getItem('favoriteProgrammingLanguage')));

// 清除本地存储或会话存储
sessionStorage.clear()

// 移除某个键值对
sessionStorage.removeItem('Name1');
```

### 1.本地存储和会话存储的相同点、不同点

**相同点：**

1、存储大小均为5M左右
2、<font color=red>**都有同源策略限制**</font>
3、仅在客户端中保存，不参与和服务器的通信

**不同点：**

1、`生命周期` —— 数据可以存储多少时间

- localStorage: 存储的数据是永久性的，除非用户人为删除否则会一直存在。
- sessionStorage: 与存储数据的脚本所在的标签页的有效期是相同的。一旦窗口或者标签页被关闭，那么所有通过 sessionStorage 存储的数据也会被删除。

2、`作用域` —— 谁拥有数据的访问权

- localStorage: 在同一个浏览器内，`同源文档`之间共享 localStorage 数据，可以互相读取、覆盖。
- sessionStorage: 与 localStorage 一样需要同一浏览器同源文档这一条件。不仅如此，sessionStorage 的作用域还被限定在了窗口中，也就是说，只有同一浏览器、同一窗口的同源文档才能共享数据。

为了更好的理解`sessionStorage`,我们来看个例子：

例如你在浏览器中打开了两个相同地址的页面A、B,虽然这两个页面的源完全相同，但是他们还是不能共享数据，因为他们是不同窗口中的。但是如果是一个窗口中，有两个同源的`iframe`元素的话，这两个`iframe`的 sessionStorage 是可以互通的。

### 2.cookie

Cookie是小甜饼的意思，主要有以下特点：

1、顾名思义，Cookie 确实非常小，它的大小限制为4KB左右

2、主要用途是保存登录信息和标记用户(比如购物车)等，不过随着localStorage的出现，现在购物车的工作Cookie承担的较少了

3、一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效

4、每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题

5、原生API不如storage友好，需要自己封装函数

**用法(API)**

服务端向客户端发送的cookie(HTTP头,不带参数)：
`Set-Cookie: <cookie-name>=<cookie-value>` (name可选)

服务端向客户端发送的cookie(HTTP头，带参数)：
`Set-Cookie: <cookie-name>=<cookie-value>;(可选参数1);(可选参数2)`

客户端设置cookie：

```ini
document.cookie = "<cookie-name>=<cookie-value>;(可选参数1);(可选参数2)"
```

**可选参数：**

下图是Chrome浏览器中的Cookie截图，属性分别有**Name**、**Value**、**Domain**、**Path**、**Expires/Max-age**、**Size**、**HttpOnly**、**Secure**、**SameSite**和**Priority**。

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4ffd6fde7194438bf2f2c92a8480f5c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1187&h=92&s=14975&e=png&b=f8f8f8"  width="80%"/></p>

`Domain=<domain-value>`：指定cookie可以送达的主机域名，若一级域名设置了则二级域名也能获取。也就是决定在向该域发送请求时是否携带此Cookie，Domain的设置是对子域生效的，如Domain设置为 .a.com,则b.a.com和c.a.com均可使用该Cookie，但如果设置为b.a.com,则c.a.com不可使用该Cookie。Domain参数必须以点(".")开始。

`Path=<path-value>`：指定一个URL，和**Domain**类似，也对子路径生效，例如指定path=/docs，则 ”/docs” 、 ”/docs/Web/“ 、”/docs/Web/Http”均满足匹配条件。如Cookie1和Cookie2的Domain均为a.com，但Path不同，Cookie1的Path为 /b/,而Cookie2的Path为 /b/c/,则在a.com/b页面时只可以访问Cookie1，在a.com/b/c页面时，可访问Cookie1和Cookie2。Path属性需要使用符号“/”结尾。

`Expires/Max-age`：
	`Expires`和`Max-age`均为Cookie的有效期，`Expires`是该Cookie被删除时的时间戳，格式为GMT,若设置为以前的时间，则该Cookie立刻被删除，并且该时间戳是服务器时间，不是本地时间！若不设置则默认页面关闭时删除该Cookie。
	`Max-age`也是Cookie的有效期，但它的单位为秒，即多少秒之后失效，若Max-age设置为0，则立刻失效，设置为负数，则在页面关闭时失效。Max-age默认为 -1。

`HttpOnly`：**HttpOnly**值为 *true* 或 *false*,若设置为*true*，则不允许通过脚本document.cookie去更改这个值，同样这个值在document.cookie中也不可见，但在发送请求时依旧会携带此Cookie。

`Secure`：**Secure**为Cookie的安全属性，若设置为*true*，则浏览器只会在HTTPS和SSL等安全协议中传输此Cookie，不会在不安全的HTTP协议中传输此Cookie。

`SameSite`SameSite用来限制第三方 Cookie，从而减少安全风险。它有3个属性，分别是：

​	Strict：Scrict最为严格，完全禁止第三方Cookie，跨站点时，任何情况下都不会发送Cookie

​	Lax：Lax规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。

​	None：网站可以选择显式关闭SameSite属性，将其设为None。不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效。

**关闭SameSite的方法**

- 操作方法谷歌浏览器地址栏输入：chrome://flags/
- 找到：SameSite by default cookies、Cookies without SameSite must be secure设置上面这两项设置成 Disable

`Priority`
优先级，chrome的提案，定义了三种优先级，Low/Medium/High，当cookie数量超出时，低优先级的cookie会被优先清除。在360极速浏览器和FireFox中，不存在Priority属性，不清楚在此类浏览器中设置该属性后是否生效。



示例：

```routeros
Set-Cookie: sessionid=aes7a8; HttpOnly; Path=/

document.cookie = "KMKNKK=1234;Sercure"
```

可选前缀：
`__Secure-`：以`__Secure-`为前缀的cookie，必须与secure属性一同设置，同时必须应用于安全页面（即使用HTTPS）

`__Host-`：以`__Host-`为前缀的cookie，必须与secure属性一同设置，同时必须应用于安全页面（即使用HTTPS）。必须不能设置domian属性（这样可以防止二级域名获取一级域名的cookie），path属性的值必须为”/“。

前缀使用示例：

```routeros
复制代码Set-Cookie: __Secure-ID=123; Secure; Domain=example.com
Set-Cookie: __Host-ID=123; Secure; Path=/

document.cookie = "__Secure-KMKNKK=1234;Sercure"
document.cookie = "__Host-KMKNKK=1234;Sercure;path=/"
```

### 3.Session

**基本概念**

Session是在无状态的HTTP协议下，服务端记录用户状态时用于标识具体用户的机制。它是在服务端保存的用来跟踪用户的状态的数据结构，可以保存在文件、数据库或者集群中。

在浏览器关闭后这次的Session就消失了，下次打开就不再拥有这个Session。其实并不是Session消失了，而是Session ID变了，服务器端可能还是存着你上次的Session ID及其Session 信息，只是他们是无主状态，也许一段时间后会被删除。

大多数的应用都是用Cookie来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在Cookie里面记录一个SessionID，以后每次请求把这个会话ID发送到服务器

**与Cookie的关系与区别：**

1、`Session`是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中，`Cookie`是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。

2、`Cookie`的`安全性`一般，他人可通过分析存放在本地的`Cookie`并进行`Cookie`欺骗。在安全性第一的前提下，选择`Session`更优。重要交互信息比如权限等就要放在`Session`中，一般的信息记录放`Cookie`就好了。 

3、单个`Cookie`保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个`Cookie`。 

4、当访问增多时，`Session`会较大地占用服务器的性能。考虑到减轻服务器性能方面，应当适时使用`Cookie`。 

5、`Session`的运行依赖`Session ID`，而`Session ID`是存在 Cookie 中的。也就是说，如果浏览器禁用了`Cookie`,`Session`也会失效（但是可以通过其它方式实现，比如在`url`中传递`Session ID`,即sid=xxxx）。



# 📚 css+c3



# 📚 js

## 1.js取整的方法，parseInt第二个参数是什么?（√）

1、丢弃小数部分，保留整数部分：

    parseInt(d);
    Math.trunc(d); 

两者的区别：parseInt 常常接收一个字符串作为参数，而 Math.trunc 则可以接收一个数字参数，所以如果要对数字取整，还是建议使用 Math.trunc。使用 parseInt 的时候，如果你传入的不是字符串，比如传入一个数字，parseInt 会先调用数字的 toString() 方法。

> 【知识点】parseInt()方法：字符串转数字
>
> parseInt接收两个参数：
>
> - 第一个参数`string`：要被解析的字符串，如果不是字符串会被转换，忽视空格符
> - 第二个参数`radix`：要解析的数字的基数。该值介于2~36之间。默认值为10，表示十进制。**这个参数表示将前面的字符从radix进制转化为十进制**
>   - 1.在没有指定基数，或者基数为0的情况下，parseInt()会根据`string`参数来判断数字的基数。
>     - 如果字符串`string`以"0x"或者"0X"开头, 则基数是16 (16进制).
>     - 如果字符串`string`以"0"开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。
>     - 如果字符串`string`以其它任何值开头，则基数是10 (十进制)。
>   - 2.如果`radix`在`2 ~ 36之外`会返回NaN。
>
> ```js
> // 例1
> console.log(parseInt(3, 8));  // 3
> // 例2
> console.log(parseInt(3, 2));  // NaN
> // 例3
> console.log(parseInt(3, 0));  // 3
> // 例4
> console.log(parseInt(3, 1));  // NaN
> // 例5
> console.log(parseInt(123, 5)); // 结果为38
> ```
>
> **解析如下**：
>
> - **例1**： `parseInt`里面有两个参数，第二个参数是8，表示要将`八进制`的3转换为十进制的结果，八进制中有3，转化为十进制还是3，所以返回结果为3
> - **例2**： `parseInt`里面有两个参数，第二个参数是2，表示要将`二进制`的3转化为十进制，额...，不好意思，二进制中并没有3，所以返回`NaN`
> - **例3**： `parseInt`里面有两个参数，第二个参数是0，根据规则1，默认就是十进制，直接返回3
> - **例4**： `parseInt`里面有两个参数，第二个参数是1，根据规则2，1在`2 ~ 36之外`，直接返回`NaN`。
> - **例5**： `parseInt`里面有两个参数，第二个参数是5，表示要将`五进制`的123转化为十进制，结果为38 => (`1*5^2 + 2*5^1 + 3*5^0 = 38`)



2、向上取整，有小数就整数部分加1：

```js
// 11.1取整后得到12；
// -11.1取整后得到-11。
Math.ceil(d);
```

3、向下取整，正数舍弃小数位，负数整数位减一：

```
11.1取整后得到11；

-11.1取整后得到-12。

Math.floor(d);
```

4、四舍五入：

```
Math.round(d);
```



## 2.数组转字符串、字符串转数组（√）

### 一、数组转字符串（3种方法）

同样是数组转字符串，toString()，toLocaleString()，join()，join(’,’)的区别是什么？

JavaScript 允许数组与字符串之间相互转换。其中 Array 方法对象定义了 3 个方法，可以把数组转换为字符串，如表所示。

| 数组方法         | 说明                               |
| ---------------- | ---------------------------------- |
| toString()       | 将数组转换成一个字符串             |
| toLocaleString() | 把数组转换成本地约定的字符串       |
| join()           | 将数组元素连接起来以构建一个字符串 |

**1. join()方法用于把数组中的所有元素放入一个字符串**

元素是通过指定的分隔符进行分隔的

| join()指定的分隔符                          | 说明                                                         |
| ------------------------------------------- | ------------------------------------------------------------ |
| join()                                      | 可理解为直接变成字符串，默认逗号分隔                         |
| join(’ '）                                  | 空连接                                                       |
| join(’ ，’)或者 join(’ - ‘)或者 join(’ 。’) | 中间这个逗号是手动添加的，也可以改成别的比如、。! -等等都可以 |

**2. toString()方法可把一个逻辑值转换为字符串，并返回结果**

```js
var arr = [10, 20, 30, 40];
var str = arr.toString(); //把数组转换为字符串
console.log(str);
console.log(typeof str); //返回字符串string，说明是字符串类型
// 输出：
// 10,true,30,40
// string
```

toString()方法不可以指定分隔符，但是我们可以通过replace()方法指定替换

```js
var str = arr.toString().replace(/,/gi, "-");
console.log(str); // 10-true-30-40
```

**3. toLocaleString()**：把数组转换成本地约定的字符串

```
var arr = [10, true, 30, 40];
var str = arr.toLocaleString(); //把数组转换为字符串
console.log(str); // 10,true,30,40
console.log(typeof str); //返回字符串string，说明是字符串类型

```

### 二、字符串转数组（2种方法）

| 字符串方法      | 说明                   |
| --------------- | ---------------------- |
| split() 方法    | 将字符串转换成一个数组 |
| 扩展运算符（…） | es6里面的扩展运算符    |

**1.split() 方法用于把一个字符串分割成字符串数组**

同样是用于把一个字符串分割成字符串数组，split(’,’)，split()，split(''）的区别是什么？

| split()方法        | 说明                   |
| ------------------ | ---------------------- |
| split(",")         | 以逗号分隔的转换为数组 |
| split(''）空字符串 | 每个字符之间都会被分割 |
| split()            | 可理解为直接变成数组   |

```js
var str = "aa, bb, cc, dd";
var str1 = str.split(",");
var str2 = str.split("");
var str3 = str.split();
console.log(str1); // [ 'aa', ' bb', ' cc', ' dd' ]
console.log(str2); // ['a', 'a', ',', ' ','b', 'b', ',', ' ','c', 'c', ',', ' ','d', 'd']
console.log(str3); // [ 'aa, bb, cc, dd' ]
```

**2.扩展运算符**

```js
var str = "aa,bb,cc,dd";
var str1 = [...str];
console.log(str1); // ['a', 'a', ',', 'b','b', ',', 'c', 'c',',', 'd', 'd']
```



## 3.数组常用方法（√）

### 一、改变原数组的方法7个

总结：push、pop

**1.push()末尾添加数据**

**语法:** **数组名.push(** **数据)**

**作用:** 就是往数组末尾添加数据

**返回值:** 就是这个数组的长度

```js
var arr = [10, 20, 30, 40]
res = arr.push(20)
console.log(arr);//[10,20,30,40,20]
console.log(res);//5
```

**2.pop() 末尾处删除数据**

**语法:** **数组名.pop()**

**作用:** 就是从数组的末尾删除一个数据

**返回值:** 就是你删除的那个数据

```js
var arr = [10, 20, 30, 40] 
res =arr.pop()
console.log(arr);//[10,20,30]
console.log(res);//40
```

**3.unshift() 头部添加数据**

**语法:** **数组名.unshift(** **数据)**

**作用:**  就是在数组的头部添加数据

**返回值:** 就是数组的长度

```js
var arr = [10, 20, 30, 40]
 res=arr.unshift(99)
 console.log(arr);//[99,10,20,30,40]
 console.log(res);//5
```

**4.shift()头部删除数据**

**语法:** **数组名.shift()**

**作用:**  头部删除一个数据

**返回值:**  就是删除掉的那个数据

```//shift
//shift复制代码 var arr = [10, 20, 30, 40]
 res=arr.shift()
 console.log(arr);[20,30,40]
 console.log(res);10
```

**5.reverse() 翻转数组**

**语法:** **数组名.reverse()**

**作用:** 就是用来翻转数组的

**返回值:** 就是翻转好的数组

```//reverse
//reverse复制代码var arr = [10, 20, 30, 40]
res=arr.reverse()
console.log(arr);//[40,30,20,10]
console.log(res);//[40,30,20,10]
```

**6.sort() 排序**

**语法一**: 数组名.sort()   会排序，会按照位排序

**语法二**: 数组名.sort(function (a,b) {return a-b})  会正序排列

**语法三**: 数组名.sort(function (a,b) {return b-a})  会倒序排列

```js
var arr = [2, 63, 48, 5, 4, 75, 69, 11, 23]
arr.sort()
console.log(arr); // [ 11, 2, 23, 4, 48, 5, 63, 69, 75]
arr.sort(function(a,b){return(a-b)})
console.log(arr); // [2,  4,  5, 11, 23, 48, 63, 69, 75     ]
arr.sort(function(a,b){return(b-a)})
console.log(arr); // [75, 69, 63, 48, 23, 11,  5,  4,  2]
```

**7.splice()  截取数组**

**语法一**: 数组名.splice(开始索引,多少个)

​	作用: 就是用来截取数组的

​	返回值: 是一个新数组 里面就是你截取出来的数据

**语法二**: 数组名.splice(开始索引,多少个,你要插入的数据)

​	作用: 删除并插入数据

​	注意: 从你的开始索引起

​	返回值: 是一个新数组 里面就是你截取出来的数据

```//splice()
var arr = [2, 63, 48, 5, 4, 75]
res = arr.splice(1,2)
console.log(arr); // [ 2, 5, 4, 75 ]
console.log(res); // [ 63, 48 ]
//******************************
//splice() 语法二
var arr = [2, 63, 48, 5, 4, 75]
res = arr.splice(1,1,99999,88888)
console.log(arr); // [2, 99999, 88888, 48, 5, 4, 75]
console.log(res); // [ 63 ]
```

### 二、不改变原数组的方法5个

**1.concat() 合并数组**

**语法:** **数组名.concat(** **数据)**

**作用:**  合并数组的

**返回值:**  一个新的数组

```js
var arr = [10, 20, 10, 30, 40, 50, 60]
res = arr.concat(20,"小敏",50)
console.log(arr); // [10, 20, 10, 30, 40, 50, 60]
console.log(res); // [10, 20, 10, 30, 40, 50, 60, 20,"小敏",50]
```

**2.join()  数组转字符串**

**语法:** **数组名.join('****连接符')**

**作用:** 就是把一个数组转成字符串

**返回值:**  就是转好的一个字符串

```js
var arr = [10, 20, 10, 30, 40, 50, 60]
res = arr.join("+")
console.log(arr); // var arr = [10, 20, 10, 30, 40, 50, 60]
console.log(res); // 10+20+10+30+40+50+60
```

**3.slice() 截取数组的一部分数据**

**语法:** **数组名.slice(** **开始索引,** **结束索引)**

**作用:** 就是截取数组中的一部分数据

**返回值:** 就是截取出来的数据 放到一个新的数组中

**注意:** 包前不好后 包含开始索引不包含结束索引

```//slice
var arr = [10, 20, 10, 30, 40, 50, 60]
res = arr.slice(1,4)
console.log(arr); // [10, 20, 10, 30, 40, 50, 60]
console.log(res); // [20, 10, 30]
```

**4.indexOf() 从左检查数组中有没有这个数值**

**语法一:** **数组名.indexOf(要查询的数据)**

**作用:** 就是检查这个数组中有没有该数据

如果有就返回该数据**第一次**出现的索引

如果没有返回 -1

**语法二:** **数组名.indexOf(要查询的数据, 开始索引)**

```//indexOf
var arr = [10, 20, 10, 30, 40, 50, 60]
res = arr.indexOf(10)
console.log(arr); // [10, 20, 10, 30, 40, 50, 60]
console.log(res); // 0
//*************************************
//indexOf  语法二
var arr = [10, 20, 10, 30, 40, 50, 60]
res = arr.indexOf(10,1)
console.log(arr); // [10, 20, 10, 30, 40, 50, 60]
console.log(res); // 2
```

**5.lastIndexOf() 从右检查数组中有没有这个数值**

**语法一:** **数组名.indexOf(** **要查询的数据)**

**作用:** 就是检查这个数组中有没有该数据

如果有就返回该数据**第一次**出现的索引

如果没有返回 -1

**语法二:** **数组名.lastIndexOf(** **要查询的数据,** **开始索引)**

```//lastIndexOf
var arr = [10, 20, 10, 30, 40, 50, 60]
res = arr.lastIndexOf(50)
console.log(arr) 
console.log(res);
//*************************************
//lastIndexOf 语法二
var arr = [10, 20, 10, 30, 40, 50, 60]
res = arr.lastIndexOf(50,4)
console.log(arr)
console.log(res);
```

### 三、ES6新增的数组方法7个（都不改变原数组）

**1. forEach()  用来循环遍历数组**

**语法**: 数组名.forEach(function (item,index,arr) {})

- item : 这个表示的是数组中的每一项
- index : 这个表示的是每一项对应的索引
- arr : 这个表示的是原数组

**作用**: 就是用来循环遍历数组的 代替了我们的for

```//forEach
var arr = [1, 2, 3, 4, 5]
var res = arr.forEach(function (item, index, arr) {
    console.log(item, "------", index, "-------", arr);
})
// 输出：
// 1 ------ 0 ------- [ 1, 2, 3, 4, 5 ]
// 2 ------ 1 ------- [ 1, 2, 3, 4, 5 ]
// 3 ------ 2 ------- [ 1, 2, 3, 4, 5 ]
// 4 ------ 3 ------- [ 1, 2, 3, 4, 5 ]
// 5 ------ 4 ------- [ 1, 2, 3, 4, 5 ]
```

**2.map()  映射数组**

**语法:** 数组名.map(function (item,index,arr) {})

- item : 这个表示的是数组中的每一项
- index : 这个表示的是每一项对应的索引
- arr : 这个表示的是原数组

**作用**: 就是用来数组映射

**返回值:** 必然是一个映射完毕的数组；这个数组和原数组长度一样，不改变原数组

```js
var arr = [1, 2, 3, 4, 5]
var res = arr.map(function (item) {
    return item*1000
})
console.log(arr);
console.log(res);
// 返回值：
// [ 1, 2, 3, 4, 5 ]
// [ 1000, 2000, 3000, 4000, 5000 ]
```

**3.filter()  过滤数组**

**语法**: 数组名.filter(function (item,index,arr) {})

- item : 这个表示的是数组中的每一项
- index : 这个表示的是每一项对应的索引
- arr : 这个表示的是原数组

**作用**: 用来过滤数组的

**返回值**: 如果有就是过滤(筛选)出来的数据 保存在一个数组中；如果没有返回一个空数组

```//filter
var arr = [1, 2, 3, 4, 5]
var res = arr.filter(function (item) {
    return item > 2
})
console.log(arr);
console.log(res);
// 返回值：
// [ 1, 2, 3, 4, 5 ]
// [ 3, 4, 5 ]
```

**4.every()  判断数组是不是满足所有条件**

**语法**: 数组名.every(function (item,index,arr) {})

- item : 这个表示的是数组中的每一项
- index : 这个表示的是每一项对应的索引
- arr : 这个表示的是原数组

**作用**: 主要是用来判断数组中是不是 每一个 都满足条件。只有所有的都满足条件返回的是true，只要有一个不满足返回的就是false

**返回值**: 是一个布尔值 

**注意**: 要以return的形式执行返回条件

```//every
//every复制代码var arr = [1, 2, 3, 4, 5]
var res = arr.every(function (item) {
    return item > 0
})
console.log(res);//打印结果  true
```

**5.some() 数组中有没有满足条件的**

**语法**: 数组名.some(function (item,index,arr) {})

- item : 这个表示的是数组中的每一项
- index : 这个表示的是每一项对应的索引
- arr : 这个表示的是原数组

**作用**: 主要是用来判断数组中是不是 每一个 都满足条件。只有有一个满足条件返回的是true，只要都不满足返回的就是false

**返回值**: 是一个布尔值

**注意**: 要以return的形式执行返回条件

```//some
var arr = [1, 2, 3, 4, 5]
var res = arr.some(function (item) {
    return item > 3
})
console.log(res); //true
```

**6.find() 用来获取数组中满足条件的第一个数据**

**语法**: 数组名.find(function (item,index,arr) {})

- item : 这个表示的是数组中的每一项
- index : 这个表示的是每一项对应的索引
- arr : 这个表示的是原数组

**作用**: 用来获取数组中满足条件的数据

**返回值**: 如果有 就是满足条件的第一个数据；如果没有就是undefined

**注意**: 要以return的形式执行返回条件

```//find
var arr = [1, 2, 3, 4, 5]
var res = arr.find(function (item) {
    return item > 3
})
console.log(res) //4
```

**7.reduce() 累加后的效果**

**语法**: 数组名.reduce(function (prev,item,index,arr) {},初始值)

- prev :一开始就是初始值 当第一次有了结果以后；这个值就是第一次的结果
- item : 这个表示的是数组中的每一项
- index : 这个表示的是每一项对应的索引
- arr : 这个表示的是原数组

**作用**: 就是用来累加的

**返回值**: 就是累加后的结果

**注意**: 以return的形式书写返回条件

```js
var arr = [1, 2, 3, 4, 5]
var res = arr.reduce(function (prev, item) {
    return prev *= item
}, 1)
console.log(res); //120
```



## 4.数组深拷贝方法

参考：[前端面试 第三篇 js之路 深拷贝与浅拷贝 - 掘金 (juejin.cn)](https://juejin.cn/post/7134970746580762637?searchId=20230903212139B6B7DB5B5E108D8F55BD)、[JavaScript深拷贝和浅拷贝看这篇就够了 - 掘金 (juejin.cn)](https://juejin.cn/post/6994453856063062053#heading-6)、[前端数组、对象的浅拷贝和深拷贝 - 掘金 (juejin.cn)](https://juejin.cn/post/7020348927643746312)、[浅拷贝与深拷贝 - 掘金 (juejin.cn)](https://juejin.cn/post/6844904197595332622)

**深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。**

**浅拷贝**: 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以**如果其中一个对象改变了这个地址，就会影响到另一个对象**。（只是拷贝了指针，使得两个指针指向同一个地址，这样在对象块结束，调用函数析构的时，会造成同一份资源析构2次，即delete同一块内存2次，造成程序崩溃）；

<p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/715c839f767d41dc98669788c9705772~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=634&h=277&s=82226&e=png&b=fdf9f8" alt="image.png"  width="50%"/></p>

**深拷贝**: 深拷贝是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象（新旧对象不共享同一块内存），且修改新对象不会影响原对象（深拷贝采用了在堆内存中申请新的空间来存储数据，这样每个可以避免指针悬挂）

<p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5058d13e4a548a3b40e0ae074ffbb92~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=634&h=373&s=84518&e=png&b=fefdfd" alt="image.png"  width="50%"/></p>

【默认情况下基本数据类型（number，string，null，undefined，boolean）都是深拷贝。】

<font color=red>**赋值和深/浅拷贝的区别**</font>，比较的前提都是**针对引用类型**：

- 当我们把一个对象赋值给一个新的变量时，**赋的其实是该对象的在栈中的地址，而不是堆中的数据**。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。
- 浅拷贝：重新在堆中创建内存，拷贝前后对象的基本数据类型互不影响，但拷贝前后对象的引用类型因共享同一块内存，会相互影响。
- 深拷贝：从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝,拷贝前后的两个对象互不影响。

<table>
	<tr>
        <th  colspan=4 align="center">对原始数据的影响</th>
    </tr>
    <tr>
        <th width=100px bgcolor=skyblue></th>
        <th bgcolor=skyblue>和原数据是否指向同一对象</th>
        <th bgcolor=skyblue>第一层数据为基本数据类型</th>
        <th bgcolor=skyblue>原数据包含子对象（引用数据类型）</th>
    </tr>
    <tr>
        <td>赋值</td>
        <td>是</td>
        <td>赋值后的数据改变，会使原数据一同改变</td>
        <td>赋值后的数据改变，会使原数据一同改变</td>
    </tr>
    <tr>
        <td>浅拷贝</td>
        <td>否</td>
        <td>浅拷贝后的数据改变，不会使原数据一同改变</td>
        <td>浅拷贝后的数据改变，会使原数据一同改变</td>
    </tr>
</table>

举例：

```
// 对象赋值
let obj1 = {
 name: "Chen",
 age: 18,
 hobby: ["see a film", "write the code", "play basketball", "tourism"],
};
let obj2 = obj1;
obj2.name = "Forever";
obj2.hobby[1] = "swim";
obj2.hobby[2] = "alpinism";
console.log("obj1===>", obj1);
console.log("obj2===>", obj2);
// 输出为：
obj1===> {
  name: 'Forever',
  age: 18,
  hobby: [ 'see a film', 'swim', 'alpinism', 'tourism' ]
}
obj2===> {
  name: 'Forever',
  age: 18,
  hobby: [ 'see a film', 'swim', 'alpinism', 'tourism' ]
}
// 结论：对象中基本属性和引用属性都发生改变
```

```js
// 浅拷贝
let obj1 = {
 name: "Chen",
 age: 18,
 hobby: ["see a film", "write the code", "play basketball", "tourism"],
};
let obj3 = { ...obj1 };
obj3.name = "Forever";
obj3.hobby[1] = "swim";
obj3.hobby[2] = "alpinism";
console.log("obj1===>", obj1);
console.log("obj3===>", obj3);
// 输出为：
obj1===> {
  name: 'Chen',
  age: 18,
  hobby: [ 'see a film', 'swim', 'alpinism', 'tourism' ]
}
obj3===> {
  name: 'Forever',
  age: 18,
  hobby: [ 'see a film', 'swim', 'alpinism', 'tourism' ]
}
// 结论：浅拷贝时，对象中基本属性不变，引用属性发生变化
```

**注意：当拷贝对象只有一层的时候，是深拷贝**



### 浅拷贝的实现

Object.assign()



1. 数组实现深拷贝可以使用以下方法

- 使用`slice()`
- 使用`concat()`
- ES6扩展运算符[...str]
- Array.from()
- 



### 深拷贝的实现：

- JSON.parse(JSON.stringify())

- jQuery.extend()方法



## 5.改变this的方法，apply和call最初设计的时候为什么要设计这两个，为什么apply参数是数组call不是



## 6.轮播图实现思路



1 实习内容介绍，你们的分页怎么实现，假如不给你total值，你可以实现分页吗，你觉得一个分页组件的核心要素是什么（有没有佬解答一下）
7渲染10w条数据怎么优化，虚拟列表技术上怎么实现，闪烁怎么解决
8常见性能优化手段
9假如用户打开了你的网站，但是是白屏你怎么解决
10说一下hashmap，常见数据结构
12nodejs有没有接触
13你对前端的看法，你更想做前端的哪个方向

# 📚 浏览器

## 1.跨域，强缓存协商缓存





## 2.前端缓存方法





# 📚 面试题带坑

## 1.console.log(["1", "2", "3"].map(parseInt));的输出值是多少？

来源：[parseInt()函数绝不是你想的那么简单~~ - 掘金 (juejin.cn)](https://juejin.cn/post/7049161354703273998)

【知识点】：map()和parseInt()

【分析】`map`方法可以将一个数组映射为一个新数组。它接收一个`callback`回调函数作为参数，这个回调函数体现了将原数组映射成新数组的映射关系。原数组在循环遍历数组每一项时，都会调用一次`callback`回调函数，并传入三个参数：

- 当前正在遍历的元素
- 元素索引
- 原数组本身 (这个参数基本不使用)

`callback`函数对当前遍历的元素进行包装执行，得到的返回值就是新数组中对应的结果

`parseInt`接收两个参数：

- 第一个参数`string`：要被解析的字符串，如果不是字符串会被转换，忽视空格符
- 第二个参数`radix`：要解析的数字的基数。该值介于`2 ~ 36`之间。默认值为10，表示十进制。这个参数表示**将前面的字符从radix进制转化为十进制**

把上面的代码的完整写法为：

```
console.log(
  ["1", "2", "3"].map(function (item, index, arr) {
    console.log(item + "-----" + index);
    return parseInt(item, index);
  })
);
```

每次每一项给parseInt传入的值为：

```
1-----0
2-----1
3-----2
```

所以最终结果为：[ 1, NaN, NaN ]
