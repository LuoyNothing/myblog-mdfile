---
title: 📣-面试八股文-html-css-js（持续更新中）
date: 2023-09-03 16:44:25
categories: 八股文
tags: ['html~css~js', '持续更新中']
comments: true
---

<meta name="referrer" content="no-referrer"/>

# 📚 html 和 h5

## 1. h5新增了哪些新特性√

1. 语义化标签，例如header，footer，section，article等。 语义化标签的作用：提升页面的阅读性(结构性增强)，更有利于SEO，对于使用屏幕阅读器的人来说会更友好(有明显的语气差别，例如strong标签内的内容会重读)；还新增了一些状态标签、列表标签、文本标签。
2. 新增媒体元素，audio、video标签能够很容易的输出音频或视频流，提供便利的获取文件信息的API
3. 新增的表单控件：calendar、date、time、email、url、search 
4. 用于绘画的canvas属性 Canvas API 提供了一个通过JavaScript 和 HTML的**canvas**元素来绘制图形的方式。它可以用于动画、游戏画面、数据可视化、图片编辑以及实时视频处理等方面。
5. 新增本地存储方式：sessionStorage、localStorage。sessionStorage 用于存储会话级别的数据，会话关闭，数据消失，不可设置过期时间。localStorage 用于存储需要进行持久化存储的数据，只要不主动删除，数据不会消失。
6. 新的技术：webworker、websocket。 webworker：用于多线程编程；websocket：客户端与服务端双向数据通信协议

## 2.localstorage、sessionstorage可以跨域吗✓

本地存储和会话存储都存储键值对。

**本地存储和会话存储的主要区别在于**，**在关闭浏览器后**，**存储在会话存储中的键值对会丢失**。下面是基本的使用（两者API一样，这里列举的是会话存储）：

```
// 保存键值对、获取键值对
sessionStorage.setItem('Name1', 'uiu');
sessionStorage.getItem('Name1');

// 保存数组，获取数据，如果不用JSON.parse()，则得到的是字符串
let ProgrammingLanguage = ['Java', 'Python', 'JavaScript', 'GO+']
sessionStorage.setItem('favoriteProgrammingLanguage',JSON.stringify(ProgrammingLanguage));
console.log(JSON.parse(sessionStorage.getItem('favoriteProgrammingLanguage')));

// 清除本地存储或会话存储
sessionStorage.clear()

// 移除某个键值对
sessionStorage.removeItem('Name1');
```

### 1.本地存储和会话存储的相同点、不同点

**相同点：**

1、存储大小均为5M左右
2、<font color=red>**都有同源策略限制**</font>
3、仅在客户端中保存，不参与和服务器的通信

**不同点：**

1、`生命周期` —— 数据可以存储多少时间

- localStorage: 存储的数据是永久性的，除非用户人为删除否则会一直存在。
- sessionStorage: 与存储数据的脚本所在的标签页的有效期是相同的。一旦窗口或者标签页被关闭，那么所有通过 sessionStorage 存储的数据也会被删除。

2、`作用域` —— 谁拥有数据的访问权

- localStorage: 在同一个浏览器内，`同源文档`之间共享 localStorage 数据，可以互相读取、覆盖。
- sessionStorage: 与 localStorage 一样需要同一浏览器同源文档这一条件。不仅如此，sessionStorage 的作用域还被限定在了窗口中，也就是说，只有同一浏览器、同一窗口的同源文档才能共享数据。

为了更好的理解`sessionStorage`,我们来看个例子：

例如你在浏览器中打开了两个相同地址的页面A、B,虽然这两个页面的源完全相同，但是他们还是不能共享数据，因为他们是不同窗口中的。但是如果是一个窗口中，有两个同源的`iframe`元素的话，这两个`iframe`的 sessionStorage 是可以互通的。

## 3. cookie有哪些属性，cookie和session的区别√

### 1.cookie

Cookie是小甜饼的意思，主要有以下特点：

1、顾名思义，Cookie 确实非常小，它的大小限制为4KB左右

2、主要用途是保存登录信息和标记用户(比如购物车)等，不过随着localStorage的出现，现在购物车的工作Cookie承担的较少了

3、一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效

4、每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题

5、原生API不如storage友好，需要自己封装函数

**用法(API)**

服务端向客户端发送的cookie(HTTP头,不带参数)：
`Set-Cookie: <cookie-name>=<cookie-value>` (name可选)

服务端向客户端发送的cookie(HTTP头，带参数)：
`Set-Cookie: <cookie-name>=<cookie-value>;(可选参数1);(可选参数2)`

客户端设置cookie：

```ini
document.cookie = "<cookie-name>=<cookie-value>;(可选参数1);(可选参数2)"
```

**可选参数：**

下图是Chrome浏览器中的Cookie截图，属性分别有**Name**、**Value**、**Domain**、**Path**、**Expires/Max-age**、**Size**、**HttpOnly**、**Secure**、**SameSite**和**Priority**。

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4ffd6fde7194438bf2f2c92a8480f5c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1187&h=92&s=14975&e=png&b=f8f8f8"  width="80%"/></p>

`Domain=<domain-value>`：指定cookie可以送达的主机域名，若一级域名设置了则二级域名也能获取。也就是决定在向该域发送请求时是否携带此Cookie，Domain的设置是对子域生效的，如Domain设置为 .a.com,则b.a.com和c.a.com均可使用该Cookie，但如果设置为b.a.com,则c.a.com不可使用该Cookie。Domain参数必须以点(".")开始。

`Path=<path-value>`：指定一个URL，和**Domain**类似，也对子路径生效，例如指定path=/docs，则 ”/docs” 、 ”/docs/Web/“ 、”/docs/Web/Http”均满足匹配条件。如Cookie1和Cookie2的Domain均为a.com，但Path不同，Cookie1的Path为 /b/,而Cookie2的Path为 /b/c/,则在a.com/b页面时只可以访问Cookie1，在a.com/b/c页面时，可访问Cookie1和Cookie2。Path属性需要使用符号“/”结尾。

`Expires/Max-age`：
	`Expires`和`Max-age`均为Cookie的有效期，`Expires`是该Cookie被删除时的时间戳，格式为GMT,若设置为以前的时间，则该Cookie立刻被删除，并且该时间戳是服务器时间，不是本地时间！若不设置则默认页面关闭时删除该Cookie。
	`Max-age`也是Cookie的有效期，但它的单位为秒，即多少秒之后失效，若Max-age设置为0，则立刻失效，设置为负数，则在页面关闭时失效。Max-age默认为 -1。

`HttpOnly`：**HttpOnly**值为 *true* 或 *false*,若设置为*true*，则不允许通过脚本document.cookie去更改这个值，同样这个值在document.cookie中也不可见，但在发送请求时依旧会携带此Cookie。

`Secure`：**Secure**为Cookie的安全属性，若设置为*true*，则浏览器只会在HTTPS和SSL等安全协议中传输此Cookie，不会在不安全的HTTP协议中传输此Cookie。

`SameSite`SameSite用来限制第三方 Cookie，从而减少安全风险。它有3个属性，分别是：

​	Strict：Scrict最为严格，完全禁止第三方Cookie，跨站点时，任何情况下都不会发送Cookie

​	Lax：Lax规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。

​	None：网站可以选择显式关闭SameSite属性，将其设为None。不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效。

**关闭SameSite的方法**

- 操作方法谷歌浏览器地址栏输入：chrome://flags/
- 找到：SameSite by default cookies、Cookies without SameSite must be secure设置上面这两项设置成 Disable

`Priority`
优先级，chrome的提案，定义了三种优先级，Low/Medium/High，当cookie数量超出时，低优先级的cookie会被优先清除。在360极速浏览器和FireFox中，不存在Priority属性，不清楚在此类浏览器中设置该属性后是否生效。



示例：

```routeros
Set-Cookie: sessionid=aes7a8; HttpOnly; Path=/

document.cookie = "KMKNKK=1234;Sercure"
```

可选前缀：
`__Secure-`：以`__Secure-`为前缀的cookie，必须与secure属性一同设置，同时必须应用于安全页面（即使用HTTPS）

`__Host-`：以`__Host-`为前缀的cookie，必须与secure属性一同设置，同时必须应用于安全页面（即使用HTTPS）。必须不能设置domian属性（这样可以防止二级域名获取一级域名的cookie），path属性的值必须为”/“。

前缀使用示例：

```routeros
复制代码Set-Cookie: __Secure-ID=123; Secure; Domain=example.com
Set-Cookie: __Host-ID=123; Secure; Path=/

document.cookie = "__Secure-KMKNKK=1234;Sercure"
document.cookie = "__Host-KMKNKK=1234;Sercure;path=/"
```

### 2.Session

**基本概念**

Session是在无状态的HTTP协议下，服务端记录用户状态时用于标识具体用户的机制。它是在服务端保存的用来跟踪用户的状态的数据结构，可以保存在文件、数据库或者集群中。

在浏览器关闭后这次的Session就消失了，下次打开就不再拥有这个Session。其实并不是Session消失了，而是Session ID变了，服务器端可能还是存着你上次的Session ID及其Session 信息，只是他们是无主状态，也许一段时间后会被删除。

大多数的应用都是用Cookie来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在Cookie里面记录一个SessionID，以后每次请求把这个会话ID发送到服务器

**与Cookie的关系与区别：**

1、`Session`是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中，`Cookie`是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。

2、`Cookie`的`安全性`一般，他人可通过分析存放在本地的`Cookie`并进行`Cookie`欺骗。在安全性第一的前提下，选择`Session`更优。重要交互信息比如权限等就要放在`Session`中，一般的信息记录放`Cookie`就好了。 

3、单个`Cookie`保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个`Cookie`。 

4、当访问增多时，`Session`会较大地占用服务器的性能。考虑到减轻服务器性能方面，应当适时使用`Cookie`。 

5、`Session`的运行依赖`Session ID`，而`Session ID`是存在 Cookie 中的。也就是说，如果浏览器禁用了`Cookie`,`Session`也会失效（但是可以通过其它方式实现，比如在`url`中传递`Session ID`,即sid=xxxx）。



# 📚 css+c3

## 1.长度单位有哪些？√

A：答案如下：这里写了8个

- [CSS中的长度单位](https://www.w3school.com.cn/cssref/css_units.asp)
- CSS 有几种表示长度的不同单位。许多 CSS 属性接受“长度”值，诸如 `width`、`margin`、`padding`、`font-size` 等。长度是一个后面跟着长度单位的数字，诸如 `10px`、`2em` 等。
- 绝对单位有：
  - px 像素：我们的电脑屏幕是由一个一个“小点”组成的，每个“小点”，就是一个像素（px）。 一个像素的大小主要取决于显示器的分辨率，相同面积不同分辨率的显示屏，其像素点大小就不相同。 像素点越小，呈现的内容就越清晰、越细腻。
  - cm 厘米：可以用在网页设计，但是不太精细
  - nm 纳米
- 相对单位有：
  - em：相对于**font-size**的大小，即为font-size的倍数。如果当前元素没有font-size，则往上一级一层一层的找，如果在根元素都没有找到，则选择浏览器默认的font-size。
  - rem：相对**根元素**的字体大小，即html的font-size
  - %：相对**父元素**的大小
  - vm：相对于视口宽度大小的1%，1vm=视口宽度*1%
  - vh：相对于视口高度大小的1%，1vm=视口高度*1%
  - vmin：1vmin = 1vw 或 1vh，以较小者为准。
  - vmax：1vmax = 1vw 或 1vh，以较小者为准。

查看视口宽度的宽度：`console.log(document.documentElement.clientWidth)`



## 2.如何实现水平垂直居中？√

如果要在父元素中实现水平垂直居中：

- 子元素为行内元素/行内块元素：（可以将行内元素和行内块元素当做文本处理）
  - 水平：`text-align:center`
  - 垂直：父元素设置行号：`line-height=height`，每个子元素加上：`vertical-align:middle`
    - 如果想要实现绝对的垂直居中，可以让父元素的字体大小为0，因为vertical-align本就是受字体大小的影响

- 子元素为块元素：

  - ①使用`margin`，子元素需要高度

    - 水平：子元素设置`margin:0 auto`
    - 垂直：子元素设置`margin-top:(父元素内容-子元素盒子总高) / 2  `

  - ②使用绝对定位（有3种）

    - 绝对定位+位移

      - 父元素设置相对定位

      - ```JavaScript
        position: absolute;
        left: 50%;
        top: 50%;            
        transform: translate(-50%, -50%);
        ```

    - 绝对定位+`margin`：2种

      - ```css
        position: absolute;
        left:0;
        right:0;
        top:0;
        bottom:0
        margin: auto;
        ```

      - ```css
        position: absolute;
        left: 50%;
        /*负的一半width*/
        margin-left: -25px; 
        ```

  - ③ 弹性布局：2种

    - 方式二：父容器开启 flex 布局，随后子元素 margin: auto 

    - 加在父元素

      - ```JavaScript
        display: flex; 
        justify-content: center; 
        align-items: center;
        ```

## 3.**CSS**中隐藏元素有几种实现方式？√

参考：[css隐藏元素的六种方法_css hidden_muzidigbig的博客-CSDN博客](https://blog.csdn.net/muzidigbig/article/details/80967143#:~:text=css隐藏元素的六种方法 1 display%3Anone (通过隐藏盒子属性，脱标) 2 visibility%3Ahidden (通过隐藏盒子属性，不脱标) 3,(通过裁剪盒子，不脱标) 6 position%3Aabsolute%3B与clip%3Arect (0px 0px 0px 0px)配合 (通过裁剪绝对定位的盒子，脱标))

A：方式如下：

- ① visibility: hidden 
  - 特点：可以隐藏元素，占位
- ② display：none
  - 特点：不占位
- ③ 给元素加hidden属性，这是html5中的全局属性
  - 特点：和display一样，不占位
- ④ opacity: 0
  - 特点：占位
- ⑤ 绝对定位：
  - 主要是将其移出屏幕，优点：既能响应，也不影响布局
  - ```JavaScript
    position：relative;
    left:-99999px;
    top:-90999px;
    ```
- ⑥ z-index
  - 特点：不占据空间
  - ```JavaScript
    .hide{
        position:absolute;
        z-index:-1000;/* 不占据空间，无法点击 */
    }
    ```
- ⑦ 位移:
  - 特点：占据空间
  - ```JavaScript
    transform: scale(0,0)/* 占据空间，无法点击 */
    ```

 <table>
    <tr>
    	<th>方法比较</th>
        <th>visibility: hidden</th>
        <th>opacity: 0</th>
        <th>overflow:hidden;</th>
        <th>绝对定位</th>
        <th>位移</th>
        <th>z-index</th>
        <th>display:none</th>
        <th>加hidden属性</th>
    </tr>
    <tr>
        <td>是否占位？</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
        <td>×</td>
        <td>×</td>
        <td>×</td>
    </tr>
    <tr>
        <td>性能</td>
        <td>会引起重绘，不会引起回流</td>
        <td>只造成本元素重绘，性能消耗较少</td>
        <td>用来隐藏元素溢出部分，无法响应点击事件</td>
        <td></td>
        <td></td>
        <td></td>
        <td>无法响应事件，引起页面回流与重绘，性能消耗大</td>
        <td></td>
    </tr>
</table>

<p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6a89c749c884a578e3552abc83d033f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1368&h=436&s=204522&e=png&a=1&b=d8dbda" alt="image.png"  width="80%"/></p>



# 📚 js

## 1.js取整的方法，parseInt第二个参数是什么?（√）

1、丢弃小数部分，保留整数部分：

    parseInt(d);
    Math.trunc(d); 

两者的区别：parseInt 常常接收一个字符串作为参数，而 Math.trunc 则可以接收一个数字参数，所以如果要对数字取整，还是建议使用 Math.trunc。使用 parseInt 的时候，如果你传入的不是字符串，比如传入一个数字，parseInt 会先调用数字的 toString() 方法。

> 【知识点】parseInt()方法：字符串转数字
>
> parseInt接收两个参数：
>
> - 第一个参数`string`：要被解析的字符串，如果不是字符串会被转换，忽视空格符
> - 第二个参数`radix`：要解析的数字的基数。该值介于2~36之间。默认值为10，表示十进制。**这个参数表示将前面的字符从radix进制转化为十进制**
>   - 1.在没有指定基数，或者基数为0的情况下，parseInt()会根据`string`参数来判断数字的基数。
>     - 如果字符串`string`以"0x"或者"0X"开头, 则基数是16 (16进制).
>     - 如果字符串`string`以"0"开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。
>     - 如果字符串`string`以其它任何值开头，则基数是10 (十进制)。
>   - 2.如果`radix`在`2 ~ 36之外`会返回NaN。
>
> ```js
> // 例1
> console.log(parseInt(3, 8));  // 3
> // 例2
> console.log(parseInt(3, 2));  // NaN
> // 例3
> console.log(parseInt(3, 0));  // 3
> // 例4
> console.log(parseInt(3, 1));  // NaN
> // 例5
> console.log(parseInt(123, 5)); // 结果为38
> ```
>
> **解析如下**：
>
> - **例1**： `parseInt`里面有两个参数，第二个参数是8，表示要将`八进制`的3转换为十进制的结果，八进制中有3，转化为十进制还是3，所以返回结果为3
> - **例2**： `parseInt`里面有两个参数，第二个参数是2，表示要将`二进制`的3转化为十进制，额...，不好意思，二进制中并没有3，所以返回`NaN`
> - **例3**： `parseInt`里面有两个参数，第二个参数是0，根据规则1，默认就是十进制，直接返回3
> - **例4**： `parseInt`里面有两个参数，第二个参数是1，根据规则2，1在`2 ~ 36之外`，直接返回`NaN`。
> - **例5**： `parseInt`里面有两个参数，第二个参数是5，表示要将`五进制`的123转化为十进制，结果为38 => (`1*5^2 + 2*5^1 + 3*5^0 = 38`)



2、向上取整，有小数就整数部分加1：

```js
// 11.1取整后得到12；
// -11.1取整后得到-11。
Math.ceil(d);
```

3、向下取整，正数舍弃小数位，负数整数位减一：

```
11.1取整后得到11；

-11.1取整后得到-12。

Math.floor(d);
```

4、四舍五入：

```
Math.round(d);
```



## 2.数组转字符串、字符串转数组（√）

### 一、数组转字符串（3种方法）

同样是数组转字符串，toString()，toLocaleString()，join()，join(’,’)的区别是什么？

JavaScript 允许数组与字符串之间相互转换。其中 Array 方法对象定义了 3 个方法，可以把数组转换为字符串，如表所示。

| 数组方法         | 说明                               |
| ---------------- | ---------------------------------- |
| toString()       | 将数组转换成一个字符串             |
| toLocaleString() | 把数组转换成本地约定的字符串       |
| join()           | 将数组元素连接起来以构建一个字符串 |

**1. join()方法用于把数组中的所有元素放入一个字符串**

元素是通过指定的分隔符进行分隔的

| join()指定的分隔符                          | 说明                                                         |
| ------------------------------------------- | ------------------------------------------------------------ |
| join()                                      | 可理解为直接变成字符串，默认逗号分隔                         |
| join(’ '）                                  | 空连接                                                       |
| join(’ ，’)或者 join(’ - ‘)或者 join(’ 。’) | 中间这个逗号是手动添加的，也可以改成别的比如、。! -等等都可以 |

**2. toString()方法可把一个逻辑值转换为字符串，并返回结果**

```js
var arr = [10, 20, 30, 40];
var str = arr.toString(); //把数组转换为字符串
console.log(str);
console.log(typeof str); //返回字符串string，说明是字符串类型
// 输出：
// 10,true,30,40
// string
```

toString()方法不可以指定分隔符，但是我们可以通过replace()方法指定替换

```js
var str = arr.toString().replace(/,/gi, "-");
console.log(str); // 10-true-30-40
```

**3. toLocaleString()**：把数组转换成本地约定的字符串

```
var arr = [10, true, 30, 40];
var str = arr.toLocaleString(); //把数组转换为字符串
console.log(str); // 10,true,30,40
console.log(typeof str); //返回字符串string，说明是字符串类型

```

### 二、字符串转数组（2种方法）

| 字符串方法      | 说明                   |
| --------------- | ---------------------- |
| split() 方法    | 将字符串转换成一个数组 |
| 扩展运算符（…） | es6里面的扩展运算符    |

**1.split() 方法用于把一个字符串分割成字符串数组**

同样是用于把一个字符串分割成字符串数组，split(’,’)，split()，split(''）的区别是什么？

| split()方法        | 说明                   |
| ------------------ | ---------------------- |
| split(",")         | 以逗号分隔的转换为数组 |
| split(''）空字符串 | 每个字符之间都会被分割 |
| split()            | 可理解为直接变成数组   |

```js
var str = "aa, bb, cc, dd";
var str1 = str.split(",");
var str2 = str.split("");
var str3 = str.split();
console.log(str1); // [ 'aa', ' bb', ' cc', ' dd' ]
console.log(str2); // ['a', 'a', ',', ' ','b', 'b', ',', ' ','c', 'c', ',', ' ','d', 'd']
console.log(str3); // [ 'aa, bb, cc, dd' ]
```

**2.扩展运算符**

```js
var str = "aa,bb,cc,dd";
var str1 = [...str];
console.log(str1); // ['a', 'a', ',', 'b','b', ',', 'c', 'c',',', 'd', 'd']
```



## 3.数组常用方法（√）

### 一、改变原数组的方法7个

总结：push、pop

**1.push()末尾添加数据**

**语法:** **数组名.push(** **数据)**

**作用:** 就是往数组末尾添加数据

**返回值:** 就是这个数组的长度

```js
var arr = [10, 20, 30, 40]
res = arr.push(20)
console.log(arr);//[10,20,30,40,20]
console.log(res);//5
```

**2.pop() 末尾处删除数据**

**语法:** **数组名.pop()**

**作用:** 就是从数组的末尾删除一个数据

**返回值:** 就是你删除的那个数据

```js
var arr = [10, 20, 30, 40] 
res =arr.pop()
console.log(arr);//[10,20,30]
console.log(res);//40
```

**3.unshift() 头部添加数据**

**语法:** **数组名.unshift(** **数据)**

**作用:**  就是在数组的头部添加数据

**返回值:** 就是数组的长度

```js
var arr = [10, 20, 30, 40]
 res=arr.unshift(99)
 console.log(arr);//[99,10,20,30,40]
 console.log(res);//5
```

**4.shift()头部删除数据**

**语法:** **数组名.shift()**

**作用:**  头部删除一个数据

**返回值:**  就是删除掉的那个数据

```//shift
//shift复制代码 var arr = [10, 20, 30, 40]
 res=arr.shift()
 console.log(arr);[20,30,40]
 console.log(res);10
```

**5.reverse() 翻转数组**

**语法:** **数组名.reverse()**

**作用:** 就是用来翻转数组的

**返回值:** 就是翻转好的数组

```//reverse
//reverse复制代码var arr = [10, 20, 30, 40]
res=arr.reverse()
console.log(arr);//[40,30,20,10]
console.log(res);//[40,30,20,10]
```

**6.sort() 排序**

**语法一**: 数组名.sort()   会排序，会按照位排序

**语法二**: 数组名.sort(function (a,b) {return a-b})  会正序排列

**语法三**: 数组名.sort(function (a,b) {return b-a})  会倒序排列

```js
var arr = [2, 63, 48, 5, 4, 75, 69, 11, 23]
arr.sort()
console.log(arr); // [ 11, 2, 23, 4, 48, 5, 63, 69, 75]
arr.sort(function(a,b){return(a-b)})
console.log(arr); // [2,  4,  5, 11, 23, 48, 63, 69, 75     ]
arr.sort(function(a,b){return(b-a)})
console.log(arr); // [75, 69, 63, 48, 23, 11,  5,  4,  2]
```

**7.splice()  截取数组**

**语法一**: 数组名.splice(开始索引,多少个)

​	作用: 就是用来截取数组的

​	返回值: 是一个新数组 里面就是你截取出来的数据

**语法二**: 数组名.splice(开始索引,多少个,你要插入的数据)

​	作用: 删除并插入数据

​	注意: 从你的开始索引起

​	返回值: 是一个新数组 里面就是你截取出来的数据

```//splice()
var arr = [2, 63, 48, 5, 4, 75]
res = arr.splice(1,2)
console.log(arr); // [ 2, 5, 4, 75 ]
console.log(res); // [ 63, 48 ]
//******************************
//splice() 语法二
var arr = [2, 63, 48, 5, 4, 75]
res = arr.splice(1,1,99999,88888)
console.log(arr); // [2, 99999, 88888, 48, 5, 4, 75]
console.log(res); // [ 63 ]
```

### 二、不改变原数组的方法5个

**1.concat() 合并数组**

**语法:** **数组名.concat(** **数据)**

**作用:**  合并数组的

**返回值:**  一个新的数组

```js
var arr = [10, 20, 10, 30, 40, 50, 60]
res = arr.concat(20,"小敏",50)
console.log(arr); // [10, 20, 10, 30, 40, 50, 60]
console.log(res); // [10, 20, 10, 30, 40, 50, 60, 20,"小敏",50]
```

**2.join()  数组转字符串**

**语法:** **数组名.join('****连接符')**

**作用:** 就是把一个数组转成字符串

**返回值:**  就是转好的一个字符串

```js
var arr = [10, 20, 10, 30, 40, 50, 60]
res = arr.join("+")
console.log(arr); // var arr = [10, 20, 10, 30, 40, 50, 60]
console.log(res); // 10+20+10+30+40+50+60
```

**3.slice() 截取数组的一部分数据**

**语法:** **数组名.slice(** **开始索引,** **结束索引)**

**作用:** 就是截取数组中的一部分数据

**返回值:** 就是截取出来的数据 放到一个新的数组中

**注意:** 包前不好后 包含开始索引不包含结束索引

```//slice
var arr = [10, 20, 10, 30, 40, 50, 60]
res = arr.slice(1,4)
console.log(arr); // [10, 20, 10, 30, 40, 50, 60]
console.log(res); // [20, 10, 30]
```

**4.indexOf() 从左检查数组中有没有这个数值**

**语法一:** **数组名.indexOf(要查询的数据)**

**作用:** 就是检查这个数组中有没有该数据

如果有就返回该数据**第一次**出现的索引

如果没有返回 -1

**语法二:** **数组名.indexOf(要查询的数据, 开始索引)**

```//indexOf
var arr = [10, 20, 10, 30, 40, 50, 60]
res = arr.indexOf(10)
console.log(arr); // [10, 20, 10, 30, 40, 50, 60]
console.log(res); // 0
//*************************************
//indexOf  语法二
var arr = [10, 20, 10, 30, 40, 50, 60]
res = arr.indexOf(10,1)
console.log(arr); // [10, 20, 10, 30, 40, 50, 60]
console.log(res); // 2
```

**5.lastIndexOf() 从右检查数组中有没有这个数值**

**语法一:** **数组名.indexOf(** **要查询的数据)**

**作用:** 就是检查这个数组中有没有该数据

如果有就返回该数据**第一次**出现的索引

如果没有返回 -1

**语法二:** **数组名.lastIndexOf(** **要查询的数据,** **开始索引)**

```//lastIndexOf
var arr = [10, 20, 10, 30, 40, 50, 60]
res = arr.lastIndexOf(50)
console.log(arr) 
console.log(res);
//*************************************
//lastIndexOf 语法二
var arr = [10, 20, 10, 30, 40, 50, 60]
res = arr.lastIndexOf(50,4)
console.log(arr)
console.log(res);
```

### 三、ES6新增的数组方法7个（都不改变原数组）

**1. forEach()  用来循环遍历数组**

**语法**: 数组名.forEach(function (item,index,arr) {})

- item : 这个表示的是数组中的每一项
- index : 这个表示的是每一项对应的索引
- arr : 这个表示的是原数组

**作用**: 就是用来循环遍历数组的 代替了我们的for

```//forEach
var arr = [1, 2, 3, 4, 5]
var res = arr.forEach(function (item, index, arr) {
    console.log(item, "------", index, "-------", arr);
})
// 输出：
// 1 ------ 0 ------- [ 1, 2, 3, 4, 5 ]
// 2 ------ 1 ------- [ 1, 2, 3, 4, 5 ]
// 3 ------ 2 ------- [ 1, 2, 3, 4, 5 ]
// 4 ------ 3 ------- [ 1, 2, 3, 4, 5 ]
// 5 ------ 4 ------- [ 1, 2, 3, 4, 5 ]
```

**2.map()  映射数组**

**语法:** 数组名.map(function (item,index,arr) {})

- item : 这个表示的是数组中的每一项
- index : 这个表示的是每一项对应的索引
- arr : 这个表示的是原数组

**作用**: 就是用来数组映射

**返回值:** 必然是一个映射完毕的数组；这个数组和原数组长度一样，不改变原数组

```js
var arr = [1, 2, 3, 4, 5]
var res = arr.map(function (item) {
    return item*1000
})
console.log(arr);
console.log(res);
// 返回值：
// [ 1, 2, 3, 4, 5 ]
// [ 1000, 2000, 3000, 4000, 5000 ]
```

**3.filter()  过滤数组**

**语法**: 数组名.filter(function (item,index,arr) {})

- item : 这个表示的是数组中的每一项
- index : 这个表示的是每一项对应的索引
- arr : 这个表示的是原数组

**作用**: 用来过滤数组的

**返回值**: 如果有就是过滤(筛选)出来的数据 保存在一个数组中；如果没有返回一个空数组

```//filter
var arr = [1, 2, 3, 4, 5]
var res = arr.filter(function (item) {
    return item > 2
})
console.log(arr);
console.log(res);
// 返回值：
// [ 1, 2, 3, 4, 5 ]
// [ 3, 4, 5 ]
```

**4.every()  判断数组是不是满足所有条件**

**语法**: 数组名.every(function (item,index,arr) {})

- item : 这个表示的是数组中的每一项
- index : 这个表示的是每一项对应的索引
- arr : 这个表示的是原数组

**作用**: 主要是用来判断数组中是不是 每一个 都满足条件。只有所有的都满足条件返回的是true，只要有一个不满足返回的就是false

**返回值**: 是一个布尔值 

**注意**: 要以return的形式执行返回条件

```//every
//every复制代码var arr = [1, 2, 3, 4, 5]
var res = arr.every(function (item) {
    return item > 0
})
console.log(res);//打印结果  true
```

**5.some() 数组中有没有满足条件的**

**语法**: 数组名.some(function (item,index,arr) {})

- item : 这个表示的是数组中的每一项
- index : 这个表示的是每一项对应的索引
- arr : 这个表示的是原数组

**作用**: 主要是用来判断数组中是不是 每一个 都满足条件。只有有一个满足条件返回的是true，只要都不满足返回的就是false

**返回值**: 是一个布尔值

**注意**: 要以return的形式执行返回条件

```//some
var arr = [1, 2, 3, 4, 5]
var res = arr.some(function (item) {
    return item > 3
})
console.log(res); //true
```

**6.find() 用来获取数组中满足条件的第一个数据**

**语法**: 数组名.find(function (item,index,arr) {})

- item : 这个表示的是数组中的每一项
- index : 这个表示的是每一项对应的索引
- arr : 这个表示的是原数组

**作用**: 用来获取数组中满足条件的数据

**返回值**: 如果有 就是满足条件的第一个数据；如果没有就是undefined

**注意**: 要以return的形式执行返回条件

```//find
var arr = [1, 2, 3, 4, 5]
var res = arr.find(function (item) {
    return item > 3
})
console.log(res) //4
```

**7.reduce() 累加后的效果**

**语法**: 数组名.reduce(function (prev,item,index,arr) {},初始值)

- prev :一开始就是初始值 当第一次有了结果以后；这个值就是第一次的结果
- item : 这个表示的是数组中的每一项
- index : 这个表示的是每一项对应的索引
- arr : 这个表示的是原数组

**作用**: 就是用来累加的

**返回值**: 就是累加后的结果

**注意**: 以return的形式书写返回条件

```js
var arr = [1, 2, 3, 4, 5]
var res = arr.reduce(function (prev, item) {
    return prev *= item
}, 1)
console.log(res); //120
```



## 4.深拷贝和浅拷贝、赋值（√）

**其他问法**：数组深拷贝方法

参考：[前端面试 第三篇 js之路 深拷贝与浅拷贝 - 掘金 (juejin.cn)](https://juejin.cn/post/7134970746580762637?searchId=20230903212139B6B7DB5B5E108D8F55BD)、[JavaScript深拷贝和浅拷贝看这篇就够了 - 掘金 (juejin.cn)](https://juejin.cn/post/6994453856063062053#heading-6)、[前端数组、对象的浅拷贝和深拷贝 - 掘金 (juejin.cn)](https://juejin.cn/post/7020348927643746312)、[浅拷贝与深拷贝 - 掘金 (juejin.cn)](https://juejin.cn/post/6844904197595332622)

**深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。**

**浅拷贝**: 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以**如果其中一个对象改变了这个地址，就会影响到另一个对象**。（只是拷贝了指针，使得两个指针指向同一个地址，这样在对象块结束，调用函数析构的时，会造成同一份资源析构2次，即delete同一块内存2次，造成程序崩溃）；

<p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/715c839f767d41dc98669788c9705772~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=634&h=277&s=82226&e=png&b=fdf9f8" alt="image.png"  width="50%"/></p>

**深拷贝**: 深拷贝是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象（新旧对象不共享同一块内存），且修改新对象不会影响原对象（深拷贝采用了在堆内存中申请新的空间来存储数据，这样每个可以避免指针悬挂）

<p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5058d13e4a548a3b40e0ae074ffbb92~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=634&h=373&s=84518&e=png&b=fefdfd" alt="image.png"  width="50%"/></p>

【默认情况下基本数据类型（number，string，null，undefined，boolean）都是深拷贝。】

<font color=red>**赋值和深/浅拷贝的区别**</font>，比较的前提都是**针对引用类型**：

- 当我们把一个对象赋值给一个新的变量时，**赋的其实是该对象的在栈中的地址，而不是堆中的数据**。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。
- 浅拷贝：重新在堆中创建内存，拷贝前后对象的基本数据类型互不影响，但拷贝前后对象的引用类型因共享同一块内存，会相互影响。
- 深拷贝：从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝,拷贝前后的两个对象互不影响。

<table>
	<tr>
        <th  colspan=4 align="center">对原始数据的影响</th>
    </tr>
    <tr>
        <th width=100px bgcolor=skyblue></th>
        <th bgcolor=skyblue>和原数据是否指向同一对象</th>
        <th bgcolor=skyblue>第一层数据为基本数据类型</th>
        <th bgcolor=skyblue>原数据包含子对象（引用数据类型）</th>
    </tr>
    <tr>
        <td>赋值</td>
        <td>是</td>
        <td>赋值后的数据改变，<strong><mark>会</mark></strong>使原数据一同改变</td>
        <td>赋值后的数据改变，<strong><mark>会</mark></strong>使原数据一同改变</td>
    </tr>
    <tr>
        <td>浅拷贝</td>
        <td>否</td>
        <td>浅拷贝后的数据改变，<strong><mark>不会</mark></strong>使原数据一同改变</td>
        <td>浅拷贝后的数据改变，<strong><mark>会</mark></strong>使原数据一同改变</td>
    </tr>
    <tr>
        <td>深拷贝</td>
        <td>否</td>
        <td>浅拷贝后的数据改变，<strong><mark>不会</mark></strong>使原数据一同改变</td>
        <td>浅拷贝后的数据改变，<strong><mark>不会</mark></strong>使原数据一同改变</td>
    </tr>
</table>


举例：

```
// 对象赋值
let obj1 = {
 name: "Chen",
 age: 18,
 hobby: ["see a film", "write the code", "play basketball", "tourism"],
};
let obj2 = obj1;
obj2.name = "Forever";
obj2.hobby[1] = "swim";
obj2.hobby[2] = "alpinism";
console.log("obj1===>", obj1);
console.log("obj2===>", obj2);
// 输出为：
obj1===> {
  name: 'Forever',
  age: 18,
  hobby: [ 'see a film', 'swim', 'alpinism', 'tourism' ]
}
obj2===> {
  name: 'Forever',
  age: 18,
  hobby: [ 'see a film', 'swim', 'alpinism', 'tourism' ]
}
// 结论：对象中基本属性和引用属性都发生改变
```

```js
// 浅拷贝
let obj1 = {
 name: "Chen",
 age: 18,
 hobby: ["see a film", "write the code", "play basketball", "tourism"],
};
let obj3 = { ...obj1 };
obj3.name = "Forever";
obj3.hobby[1] = "swim";
obj3.hobby[2] = "alpinism";
console.log("obj1===>", obj1);
console.log("obj3===>", obj3);
// 输出为：
obj1===> {
  name: 'Chen',
  age: 18,
  hobby: [ 'see a film', 'swim', 'alpinism', 'tourism' ]
}
obj3===> {
  name: 'Forever',
  age: 18,
  hobby: [ 'see a film', 'swim', 'alpinism', 'tourism' ]
}
// 结论：浅拷贝时，对象中基本属性不变，引用属性发生变化
```

**注意：当拷贝对象只有一层的时候，是深拷贝**



### 浅拷贝的实现

1. **Object.assign()**

参考资料：[Object.assign()基本用法、注意点、用法](https://juejin.cn/post/6844903984675684366)

`Object.assign()` 方法用于将所有可枚举属性的值从一个或多个源对象`source`复制到目标对象。

**参数：**第一个参数是目标对象，后面的参数都是源对象。

**返回：**目标对象`target`。

```js
const target = { a: 1, b: 2 }
const source = { b: 4, c: 5 }
const returnedTarget = Object.assign(target, source)
target 			// { a: 1, b: 4, c: 5 }
returnedTarget  // { a: 1, b: 4, c: 5 }
```

**注意**：

-  如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。

-  如果只有一个参数，`Object.assign`会直接返回该参数。

-  如果该参数不是对象，则会先转成对象，然后返回。由于`undefined`和`null`无法转成对象，所以如果它们作为第一个参数，就会报错。如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果`undefined`和`null`不在首参数，就不会报错。其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，<u>除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</u>

   ```
   let obj = {a: 1}
   Object.assign(obj, undefined) === obj // true
   Object.assign(obj, null) === obj 	  // true
   
   const v1 = 'abc'
   const v2 = true
   const v3 = 10
   const obj = Object.assign({}, v1, v2, v3)
   obj // { "0": "a", "1": "b", "2": "c" }
   ```

-  `Object.assign`拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（`enumerable: false`）。



数组的处理 `Object.assign`可以用来处理数组，但是会把数组视为对象。

```js
Object.assign([1, 2, 3], [4, 5])	// [4, 5, 3]
```

上面代码中，`Object.assign`把数组视为属性名为 `0、1、2` 的对象，因此源数组的 `0` 号属性`4`覆盖了目标数组的 `0` 号属性`1`。

2. **函数库lodash的_.clone方法**

该函数库也有提供_.clone用来做浅拷贝，后面我们会再介绍利用这个库实现深拷贝。

```js
var _ = require('lodash');
var obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};
var obj2 = _.clone(obj1);
console.log(obj1.b.f === obj2.b.f);// true
```

3. **扩展运算符...**

提供了一种非常方便的方式来执行浅拷贝，这与 Object.assign ()的功能相同。

```js
let obj1 = { name: 'Kobe', address:{x:100,y:100}}
let obj2= {... obj1}
obj1.address.x = 200;
obj1.name = 'wade'
console.log('obj2',obj2) // obj2 { name: 'Kobe', address: { x: 200, y: 100 } }
```

4. **Array.prototype.concat()**

```js
let arr = [1, 3, {
    username: 'kobe'
    }];
let arr2 = arr.concat();    
arr2[2].username = 'wade';
console.log(arr); //[ 1, 3, { username: 'wade' } ]
```

5. **Array.prototype.slice()**

```js
let arr = [1, 3, {
    username: ' kobe'
    }];
let arr3 = arr.slice();
arr3[2].username = 'wade'
console.log(arr); // [ 1, 3, { username: 'wade' } ]
```



### 深拷贝的实现：

1. **JSON.parse(JSON.stringify())**

利用`JSON.stringify`将对象转成JSON字符串，再用`JSON.parse`把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。

2. **函数库lodash的_.cloneDeep方法**

```js
var _ = require('lodash');
var obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};
var obj2 = _.cloneDeep(obj1);
console.log(obj1.b.f === obj2.b.f);// false
```

3. **jQuery.extend()方法**

jquery 有提供一個`$.extend`可以用来做 Deep Copy

```js
$.extend(deepCopy, target, object1, [objectN])  	//第一个参数为true,就是深拷贝

var $ = require('jquery');
var obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};
var obj2 = $.extend(true, {}, obj1);
console.log(obj1.b.f === obj2.b.f); // false

```

4. **手写递归方法**

递归方法实现深度拷贝原理：**遍历 对象或数组 直到里边都是基本数据类型，然后再去复制，就是深度拷贝**。

有种特殊情况需注意就是对象存在**循环引用**的情况，即对象的属性直接的引用了自身的情况，解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。关于这块如有疑惑，请仔细阅读`ConardLi大佬`[如何写出一个惊艳面试官的深拷贝?](https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000020255831)这篇文章。

```javascript
function deepClone(obj, hash = new WeakMap()) {
  if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);
  // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝
  if (typeof obj !== "object") return obj;
  // 是对象的话就要进行深拷贝
  if (hash.get(obj)) return hash.get(obj);
  let cloneObj = new obj.constructor();
  // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身
  hash.set(obj, cloneObj);
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      // 实现一个递归拷贝
      cloneObj[key] = deepClone(obj[key], hash);
    }
  }
  return cloneObj;
}
let obj = { name: 1, address: { x: 100 } };
obj.o = obj; // 对象存在循环引用的情况
let d = deepClone(obj);
obj.address.x = 200;
console.log(d);
```



数组实现深拷贝可以使用以下方法

- 使用`slice()`
- 使用`concat()`
- ES6扩展运算符[...str]
- Array.from()
- 



## 5.手写深拷贝函数 （√）

这里写了三种，参考资料：[手写深浅拷贝](https://juejin.cn/post/7264208575974834231?searchId=20230904153935A317FD4976A2592BDE92#heading-8)

1. 简单版（JSON）

```js
let a = {
    age: 1,
    jobs: {
        first: 'FE'
    }
}
let b = JSON.parse(JSON.stringify(a))
a.jobs.first = 'native'
console.log(b.jobs.first) // FE
```

2. 基础版（手写递归）

下面是一个实现 `deepClone` 函数封装的例子，通过 `for in` 遍历传入参数的属性值，如果值是引用类型则再次递归调用该函数，如果是基础数据类型就直接复制

```js
let obj1 = {
  a:{
    b:1
  }
}
function deepClone(obj) { 
  let cloneObj = {}
  for(let key in obj) {                 //遍历
    if(typeof obj[key] ==='object') { 
      cloneObj[key] = deepClone(obj[key])  //是对象就再次调用该函数递归
    } else {
      cloneObj[key] = obj[key]  //基本类型的话直接复制值
    }
  }
  return cloneObj
}
let obj2 = deepClone(obj1);
obj1.a.b = 2;
console.log(obj2);   //  {a:{b:1}}
```

3. 进阶版（递归实现）

```js
// 判断一个对象是否为复杂数据类型，即对象或函数类型，且不为 null
const isComplexDataType = obj => (typeof obj === 'object' || typeof obj === 'function') && (obj !== null)

// 定义深拷贝函数 deepClone，接受两个参数：obj 为要进行深拷贝的目标对象，hash 为已经拷贝过的对象的哈希表（用于解决循环引用问题）
const deepClone = function (obj, hash = new WeakMap()) {
  // 如果目标对象是日期对象，则直接返回一个新的日期对象，避免修改原日期对象
  if (obj.constructor === Date) {
    return new Date(obj)
  }

  // 如果目标对象是正则对象，则直接返回一个新的正则对象，避免修改原正则对象
  if (obj.constructor === RegExp){
    return new RegExp(obj)
  }

  // 如果目标对象已经被拷贝过，则从 hash 中获取已经拷贝过的对象并返回，避免出现循环引用问题
  if (hash.has(obj)) {
    return hash.get(obj)
  }

  // 获取目标对象的所有属性描述符
  let allDesc = Object.getOwnPropertyDescriptors(obj)

  // 创建一个新对象 cloneObj，并将其原型链指向 obj 的原型对象
  let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc)

  // 将目标对象和克隆对象的映射关系存入 hash 中，用于解决循环引用问题
  hash.set(obj, cloneObj)

  // 遍历目标对象的所有属性（包括字符串类型和 Symbol 类型的属性名）
  for (let key of Reflect.ownKeys(obj)) { 
    // 如果目标对象的属性值是复杂数据类型（即对象或数组），则递归调用 deepClone 函数进行深拷贝，并将拷贝结果赋值给克隆对象的对应属性
    if (isComplexDataType(obj[key]) && typeof obj[key] !== 'function') {
      cloneObj[key] = deepClone(obj[key], hash)
    } else {
      // 如果目标对象的属性值不是复杂数据类型，则直接将其赋值给克隆对象的对应属性
      cloneObj[key] = obj[key]
    }
  }
  // 返回深拷贝后的新对象
  return cloneObj
}
```



## 6.call、bind、apply的作用和区别？

其他问法：改变this的方法，apply和call最初设计的时候为什么要设计这两个，为什么apply参数是数组call不是







## 7.轮播图实现思路 （√）

实现前端轮播图（也称为轮播幻灯片或轮播广告）通常涉及以下主要步骤和思路：

1. **HTML结构：** 首先，在HTML中创建轮播图的基本结构。通常，你会使用一个包含图像或内容的容器，并为每个轮播项创建一个子元素。

```html
<div class="carousel">
  <div class="carousel-item">
    <!-- 内容或图像1 -->
  </div>
  <div class="carousel-item">
    <!-- 内容或图像2 -->
  </div>
  <!-- 更多轮播项 -->
</div>
```

2. **CSS样式：** 使用CSS样式来定义轮播图容器的外观，包括宽度、高度、位置等。还可以设置轮播项的布局和过渡效果。

```css
.carousel {
  width: 100%;
  overflow: hidden;
  position: relative;
}
.carousel-item {
  width: 100%;
  display: none; /* 隐藏所有项，除了当前活动的项 */
  transition: opacity 1s; /* 过渡效果 */
}
.carousel-item.active {
  display: block; /* 显示当前活动的项 */
}
```

3. **JavaScript交互：** 使用JavaScript来实现轮播图的交互逻辑。以下是一些常见的实现思路：
   - **自动播放：** 设置定时器，以一定的时间间隔自动切换到下一张轮播项。
   - **手动控制：** 添加前进和后退按钮，以允许用户手动浏览轮播项。
   - **指示器：** 创建轮播指示器，以显示当前轮播项的位置，并允许用户通过点击指示器来切换轮播项。
   - **循环播放：** 当到达最后一张轮播项时，循环回到第一张。
   - **响应式设计：** 确保轮播图在不同屏幕尺寸下适应，并且图像大小和数量能够自动调整。

```js
let currentSlide = 0;
const slides = document.querySelectorAll('.carousel-item');

function showSlide(index) {
  slides[currentSlide].classList.remove('active');
  slides[index].classList.add('active');
  currentSlide = index;
}

function nextSlide() {
  const next = (currentSlide + 1) % slides.length;
  showSlide(next);
}

function prevSlide() {
  const prev = (currentSlide - 1 + slides.length) % slides.length;
  showSlide(prev);
}

// 自动播放
setInterval(nextSlide, 5000);

// 手动控制按钮
const nextButton = document.getElementById('next-button');
const prevButton = document.getElementById('prev-button');

nextButton.addEventListener('click', nextSlide);
prevButton.addEventListener('click', prevSlide);
```

**优化和性能：** 对于包含大量图像的轮播图，应考虑性能优化，如懒加载图像，压缩图像大小等。



1 实习内容介绍，你们的分页怎么实现，假如不给你total值，你可以实现分页吗，你觉得一个分页组件的核心要素是什么（有没有佬解答一下）
7渲染10w条数据怎么优化，虚拟列表技术上怎么实现，闪烁怎么解决
8常见性能优化手段
9假如用户打开了你的网站，但是是白屏你怎么解决
10说一下hashmap，常见数据结构
12nodejs有没有接触
13你对前端的看法，你更想做前端的哪个方向



# 📚 ES6

## 1.ES6模块化





## 2.Promise和async/await



# 📚 浏览器

## 1.浏览器缓存（强缓存，协商缓存）具体字段头是哪些，有何区别





## 2.前端缓存方法



## 3.输入URL到页面渲染的过程



## 4.同源策略和跨域





# 📚 vue2+vue3

## 1.Vue diff算法



### 2.Vue组件通信

包括父子组件通信：父传子，子传父，兄弟组件通信





# 📚 面试题带坑

## 1.console.log(["1", "2", "3"].map(parseInt));的输出值是多少？

来源：[parseInt()函数绝不是你想的那么简单~~ - 掘金 (juejin.cn)](https://juejin.cn/post/7049161354703273998)

【知识点】：map()和parseInt()

【分析】`map`方法可以将一个数组映射为一个新数组。它接收一个`callback`回调函数作为参数，这个回调函数体现了将原数组映射成新数组的映射关系。原数组在循环遍历数组每一项时，都会调用一次`callback`回调函数，并传入三个参数：

- 当前正在遍历的元素
- 元素索引
- 原数组本身 (这个参数基本不使用)

`callback`函数对当前遍历的元素进行包装执行，得到的返回值就是新数组中对应的结果

`parseInt`接收两个参数：

- 第一个参数`string`：要被解析的字符串，如果不是字符串会被转换，忽视空格符
- 第二个参数`radix`：要解析的数字的基数。该值介于`2 ~ 36`之间。默认值为10，表示十进制。这个参数表示**将前面的字符从radix进制转化为十进制**

把上面的代码的完整写法为：

```
console.log(
  ["1", "2", "3"].map(function (item, index, arr) {
    console.log(item + "-----" + index);
    return parseInt(item, index);
  })
);
```

每次每一项给parseInt传入的值为：

```
1-----0
2-----1
3-----2
```

所以最终结果为：[ 1, NaN, NaN ]
