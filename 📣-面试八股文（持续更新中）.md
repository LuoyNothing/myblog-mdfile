---
title: 📣-面试八股文-html-css-js（持续更新中）
date: 2023-09-03 16:44:25
categories: 八股文
tags: ['html~css~js', '持续更新中']
comments: true
---

<meta name="referrer" content="no-referrer"/>

# 📚 html 和 h5

## 1. h5新增了哪些新特性√

1. 语义化标签，例如header，footer，section，article等。 语义化标签的作用：提升页面的阅读性(结构性增强)，更有利于SEO，对于使用屏幕阅读器的人来说会更友好(有明显的语气差别，例如strong标签内的内容会重读)；还新增了一些状态标签、列表标签、文本标签。
2. 新增媒体元素，audio、video标签能够很容易的输出音频或视频流，提供便利的获取文件信息的API
3. 新增的表单控件：calendar、date、time、email、url、search 
4. 用于绘画的canvas属性 Canvas API 提供了一个通过JavaScript 和 HTML的**canvas**元素来绘制图形的方式。它可以用于动画、游戏画面、数据可视化、图片编辑以及实时视频处理等方面。
5. 新增本地存储方式：sessionStorage、localStorage。sessionStorage 用于存储会话级别的数据，会话关闭，数据消失，不可设置过期时间。localStorage 用于存储需要进行持久化存储的数据，只要不主动删除，数据不会消失。
6. 新的技术：webworker、websocket。 webworker：用于多线程编程；websocket：客户端与服务端双向数据通信协议

## 2.localstorage、sessionstorage可以跨域吗✓

本地存储和会话存储都存储键值对。

**本地存储和会话存储的主要区别在于**，**在关闭浏览器后**，**存储在会话存储中的键值对会丢失**。下面是基本的使用（两者API一样，这里列举的是会话存储）：

```
// 保存键值对、获取键值对
sessionStorage.setItem('Name1', 'uiu');
sessionStorage.getItem('Name1');

// 保存数组，获取数据，如果不用JSON.parse()，则得到的是字符串
let ProgrammingLanguage = ['Java', 'Python', 'JavaScript', 'GO+']
sessionStorage.setItem('favoriteProgrammingLanguage',JSON.stringify(ProgrammingLanguage));
console.log(JSON.parse(sessionStorage.getItem('favoriteProgrammingLanguage')));

// 清除本地存储或会话存储
sessionStorage.clear()

// 移除某个键值对
sessionStorage.removeItem('Name1');
```

### 1.本地存储和会话存储的相同点、不同点

**相同点：**

1、存储大小均为5M左右
2、<font color=red>**都有同源策略限制**</font>
3、仅在客户端中保存，不参与和服务器的通信

**不同点：**

1、`生命周期` —— 数据可以存储多少时间

- localStorage: 存储的数据是永久性的，除非用户人为删除否则会一直存在。
- sessionStorage: 与存储数据的脚本所在的标签页的有效期是相同的。一旦窗口或者标签页被关闭，那么所有通过 sessionStorage 存储的数据也会被删除。

2、`作用域` —— 谁拥有数据的访问权

- localStorage: 在同一个浏览器内，`同源文档`之间共享 localStorage 数据，可以互相读取、覆盖。
- sessionStorage: 与 localStorage 一样需要同一浏览器同源文档这一条件。不仅如此，sessionStorage 的作用域还被限定在了窗口中，也就是说，只有同一浏览器、同一窗口的同源文档才能共享数据。

为了更好的理解`sessionStorage`,我们来看个例子：

例如你在浏览器中打开了两个相同地址的页面A、B,虽然这两个页面的源完全相同，但是他们还是不能共享数据，因为他们是不同窗口中的。但是如果是一个窗口中，有两个同源的`iframe`元素的话，这两个`iframe`的 sessionStorage 是可以互通的。

## 3. cookie有哪些属性，cookie和session的区别√

### 1.cookie

Cookie是小甜饼的意思，主要有以下特点：

1、顾名思义，Cookie 确实非常小，它的大小限制为4KB左右

2、主要用途是保存登录信息和标记用户(比如购物车)等，不过随着localStorage的出现，现在购物车的工作Cookie承担的较少了

3、一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效

4、每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题

5、原生API不如storage友好，需要自己封装函数

**用法(API)**

服务端向客户端发送的cookie(HTTP头,不带参数)：
`Set-Cookie: <cookie-name>=<cookie-value>` (name可选)

服务端向客户端发送的cookie(HTTP头，带参数)：
`Set-Cookie: <cookie-name>=<cookie-value>;(可选参数1);(可选参数2)`

客户端设置cookie：

```ini
document.cookie = "<cookie-name>=<cookie-value>;(可选参数1);(可选参数2)"
```

**可选参数：**

下图是Chrome浏览器中的Cookie截图，属性分别有**Name**、**Value**、**Domain**、**Path**、**Expires/Max-age**、**Size**、**HttpOnly**、**Secure**、**SameSite**和**Priority**。

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4ffd6fde7194438bf2f2c92a8480f5c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1187&h=92&s=14975&e=png&b=f8f8f8"  width="80%"/></p>

`Domain=<domain-value>`：指定cookie可以送达的主机域名，若一级域名设置了则二级域名也能获取。也就是决定在向该域发送请求时是否携带此Cookie，Domain的设置是对子域生效的，如Domain设置为 .a.com,则b.a.com和c.a.com均可使用该Cookie，但如果设置为b.a.com,则c.a.com不可使用该Cookie。Domain参数必须以点(".")开始。

`Path=<path-value>`：指定一个URL，和**Domain**类似，也对子路径生效，例如指定path=/docs，则 ”/docs” 、 ”/docs/Web/“ 、”/docs/Web/Http”均满足匹配条件。如Cookie1和Cookie2的Domain均为a.com，但Path不同，Cookie1的Path为 /b/,而Cookie2的Path为 /b/c/,则在a.com/b页面时只可以访问Cookie1，在a.com/b/c页面时，可访问Cookie1和Cookie2。Path属性需要使用符号“/”结尾。

`Expires/Max-age`：
	`Expires`和`Max-age`均为Cookie的有效期，`Expires`是该Cookie被删除时的时间戳，格式为GMT,若设置为以前的时间，则该Cookie立刻被删除，并且该时间戳是服务器时间，不是本地时间！若不设置则默认页面关闭时删除该Cookie。
	`Max-age`也是Cookie的有效期，但它的单位为秒，即多少秒之后失效，若Max-age设置为0，则立刻失效，设置为负数，则在页面关闭时失效。Max-age默认为 -1。

`HttpOnly`：**HttpOnly**值为 *true* 或 *false*,若设置为*true*，则不允许通过脚本document.cookie去更改这个值，同样这个值在document.cookie中也不可见，但在发送请求时依旧会携带此Cookie。

`Secure`：**Secure**为Cookie的安全属性，若设置为*true*，则浏览器只会在HTTPS和SSL等安全协议中传输此Cookie，不会在不安全的HTTP协议中传输此Cookie。

`SameSite`SameSite用来限制第三方 Cookie，从而减少安全风险。它有3个属性，分别是：

​	Strict：Scrict最为严格，完全禁止第三方Cookie，跨站点时，任何情况下都不会发送Cookie

​	Lax：Lax规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。

​	None：网站可以选择显式关闭SameSite属性，将其设为None。不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效。

**关闭SameSite的方法**

- 操作方法谷歌浏览器地址栏输入：chrome://flags/
- 找到：SameSite by default cookies、Cookies without SameSite must be secure设置上面这两项设置成 Disable

`Priority`
优先级，chrome的提案，定义了三种优先级，Low/Medium/High，当cookie数量超出时，低优先级的cookie会被优先清除。在360极速浏览器和FireFox中，不存在Priority属性，不清楚在此类浏览器中设置该属性后是否生效。



示例：

```routeros
Set-Cookie: sessionid=aes7a8; HttpOnly; Path=/

document.cookie = "KMKNKK=1234;Sercure"
```

可选前缀：
`__Secure-`：以`__Secure-`为前缀的cookie，必须与secure属性一同设置，同时必须应用于安全页面（即使用HTTPS）

`__Host-`：以`__Host-`为前缀的cookie，必须与secure属性一同设置，同时必须应用于安全页面（即使用HTTPS）。必须不能设置domian属性（这样可以防止二级域名获取一级域名的cookie），path属性的值必须为”/“。

前缀使用示例：

```routeros
复制代码Set-Cookie: __Secure-ID=123; Secure; Domain=example.com
Set-Cookie: __Host-ID=123; Secure; Path=/

document.cookie = "__Secure-KMKNKK=1234;Sercure"
document.cookie = "__Host-KMKNKK=1234;Sercure;path=/"
```

### 2.Session

**基本概念**

Session是在无状态的HTTP协议下，服务端记录用户状态时用于标识具体用户的机制。它是在服务端保存的用来跟踪用户的状态的数据结构，可以保存在文件、数据库或者集群中。

在浏览器关闭后这次的Session就消失了，下次打开就不再拥有这个Session。其实并不是Session消失了，而是Session ID变了，服务器端可能还是存着你上次的Session ID及其Session 信息，只是他们是无主状态，也许一段时间后会被删除。

大多数的应用都是用Cookie来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在Cookie里面记录一个SessionID，以后每次请求把这个会话ID发送到服务器

**与Cookie的关系与区别：**

1、`Session`是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中，`Cookie`是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。

2、`Cookie`的`安全性`一般，他人可通过分析存放在本地的`Cookie`并进行`Cookie`欺骗。在安全性第一的前提下，选择`Session`更优。重要交互信息比如权限等就要放在`Session`中，一般的信息记录放`Cookie`就好了。 

3、单个`Cookie`保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个`Cookie`。 当访问增多时，`Session`会较大地占用服务器的性能。考虑到减轻服务器性能方面，应当适时使用`Cookie`。 

4、`Session`的运行依赖`Session ID`，而`Session ID`是存在 Cookie 中的。也就是说，如果浏览器禁用了`Cookie`,`Session`也会失效（但是可以通过其它方式实现，比如在`url`中传递`Session ID`,即sid=xxxx）。



# 📚 css+c3

## 1.长度单位有哪些？√

A：答案如下：这里写了8个

- [CSS中的长度单位](https://www.w3school.com.cn/cssref/css_units.asp)
- CSS 有几种表示长度的不同单位。许多 CSS 属性接受“长度”值，诸如 `width`、`margin`、`padding`、`font-size` 等。长度是一个后面跟着长度单位的数字，诸如 `10px`、`2em` 等。
- 绝对单位有：
  - px 像素：我们的电脑屏幕是由一个一个“小点”组成的，每个“小点”，就是一个像素（px）。 一个像素的大小主要取决于显示器的分辨率，相同面积不同分辨率的显示屏，其像素点大小就不相同。 像素点越小，呈现的内容就越清晰、越细腻。
  - cm 厘米：可以用在网页设计，但是不太精细
  - nm 纳米
- 相对单位有：
  - em：相对于**font-size**的大小，即为font-size的倍数。如果当前元素没有font-size，则往上一级一层一层的找，如果在根元素都没有找到，则选择浏览器默认的font-size。
  - rem：相对**根元素**的字体大小，即html的font-size
  - %：相对**父元素**的大小
  - vm：相对于视口宽度大小的1%，1vm=视口宽度*1%
  - vh：相对于视口高度大小的1%，1vm=视口高度*1%
  - vmin：1vmin = 1vw 或 1vh，以较小者为准。
  - vmax：1vmax = 1vw 或 1vh，以较小者为准。

查看视口宽度的宽度：`console.log(document.documentElement.clientWidth)`



## 2.如何实现水平垂直居中？√

如果要在父元素中实现水平垂直居中：

- 子元素为行内元素/行内块元素：（可以将行内元素和行内块元素当做文本处理）
  - 水平：`text-align:center`
  - 垂直：父元素设置行号：`line-height=height`，每个子元素加上：`vertical-align:middle`
    - 如果想要实现绝对的垂直居中，可以让父元素的字体大小为0，因为vertical-align本就是受字体大小的影响

- 子元素为块元素：

  - ①使用`margin`，子元素需要高度

    - 水平：子元素设置`margin:0 auto`
    - 垂直：子元素设置`margin-top:(父元素内容-子元素盒子总高) / 2  `

  - ②使用绝对定位（有3种）

    - 绝对定位+位移

      - 父元素设置相对定位

      - ```JavaScript
        position: absolute;
        left: 50%;
        top: 50%;            
        transform: translate(-50%, -50%);
        ```

    - 绝对定位+`margin`：2种

      - ```css
        position: absolute;
        left:0;
        right:0;
        top:0;
        bottom:0
        margin: auto;
        ```

      - ```css
        position: absolute;
        left: 50%;
        /*负的一半width*/
        margin-left: -25px; 
        ```

  - ③ 弹性布局：2种

    - 方式二：父容器开启 flex 布局，随后子元素 margin: auto 

    - 加在父元素

      - ```JavaScript
        display: flex; 
        justify-content: center; 
        align-items: center;
        ```

## 3.**CSS**中隐藏元素有几种实现方式？√

参考：[css隐藏元素的六种方法_css hidden_muzidigbig的博客-CSDN博客](https://blog.csdn.net/muzidigbig/article/details/80967143#:~:text=css隐藏元素的六种方法 1 display%3Anone (通过隐藏盒子属性，脱标) 2 visibility%3Ahidden (通过隐藏盒子属性，不脱标) 3,(通过裁剪盒子，不脱标) 6 position%3Aabsolute%3B与clip%3Arect (0px 0px 0px 0px)配合 (通过裁剪绝对定位的盒子，脱标))

A：方式如下：

- ① visibility: hidden 
  - 特点：可以隐藏元素，占位
  
- ② display：none
  - 特点：不占位
  
- ③ 给元素加hidden属性，这是html5中的全局属性
  - 特点：和display一样，不占位
  
- ④ opacity: 0
  - 特点：占位
  
- ⑤ 绝对定位：
  - 主要是将其移出屏幕，优点：既能响应，也不影响布局
  - ```JavaScript
    position：relative;
    left:-99999px;
    top:-90999px;
    ```
  
- ⑥ z-index
  - 特点：不占据空间
  - ```JavaScript
    .hide{
        position:absolute;
        z-index:-1000;/* 不占据空间，无法点击 */
    }
    ```
  
- ⑦ 位移:
  - 特点：占据空间
  - `transform: scale(0,0)/* 占据空间，无法点击 */`



 <table>
    <tr>
    	<th>方法比较</th>
        <th>visibility: hidden</th>
        <th>opacity: 0</th>
        <th>overflow:hidden;</th>
        <th>绝对定位</th>
        <th>位移</th>
        <th>z-index</th>
        <th>display:none</th>
        <th>加hidden属性</th>
    </tr>
    <tr>
        <td>是否占位？</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
        <td>×</td>
        <td>×</td>
        <td>×</td>
    </tr>
    <tr>
        <td>性能</td>
        <td>会引起重绘，不会引起回流</td>
        <td>只造成本元素重绘，性能消耗较少</td>
        <td>用来隐藏元素溢出部分，无法响应点击事件</td>
        <td></td>
        <td></td>
        <td></td>
        <td>无法响应事件，引起页面回流与重绘，性能消耗大</td>
        <td></td>
    </tr>
</table>


<p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6a89c749c884a578e3552abc83d033f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1368&h=436&s=204522&e=png&a=1&b=d8dbda" alt="image.png"  width="80%"/></p>





# 📚 js

## 1.js取整的方法，parseInt第二个参数是什么?（√）

1、丢弃小数部分，保留整数部分：

    parseInt(d);
    Math.trunc(d); 

两者的区别：parseInt 常常接收一个字符串作为参数，而 Math.trunc 则可以接收一个数字参数，所以如果要对数字取整，还是建议使用 Math.trunc。使用 parseInt 的时候，如果你传入的不是字符串，比如传入一个数字，parseInt 会先调用数字的 toString() 方法。

> 【知识点】parseInt()方法：字符串转数字
>
> parseInt接收两个参数：
>
> - 第一个参数`string`：要被解析的字符串，如果不是字符串会被转换，忽视空格符
> - 第二个参数`radix`：要解析的数字的基数。该值介于2~36之间。默认值为10，表示十进制。**这个参数表示将前面的字符从radix进制转化为十进制**
>   - 1.在没有指定基数，或者基数为0的情况下，parseInt()会根据`string`参数来判断数字的基数。
>     - 如果字符串`string`以"0x"或者"0X"开头, 则基数是16 (16进制).
>     - 如果字符串`string`以"0"开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。
>     - 如果字符串`string`以其它任何值开头，则基数是10 (十进制)。
>   - 2.如果`radix`在`2 ~ 36之外`会返回NaN。
>
> ```js
> // 例1
> console.log(parseInt(3, 8));  // 3
> // 例2
> console.log(parseInt(3, 2));  // NaN
> // 例3
> console.log(parseInt(3, 0));  // 3
> // 例4
> console.log(parseInt(3, 1));  // NaN
> // 例5
> console.log(parseInt(123, 5)); // 结果为38
> ```
>
> **解析如下**：
>
> - **例1**： `parseInt`里面有两个参数，第二个参数是8，表示要将`八进制`的3转换为十进制的结果，八进制中有3，转化为十进制还是3，所以返回结果为3
> - **例2**： `parseInt`里面有两个参数，第二个参数是2，表示要将`二进制`的3转化为十进制，额...，不好意思，二进制中并没有3，所以返回`NaN`
> - **例3**： `parseInt`里面有两个参数，第二个参数是0，根据规则1，默认就是十进制，直接返回3
> - **例4**： `parseInt`里面有两个参数，第二个参数是1，根据规则2，1在`2 ~ 36之外`，直接返回`NaN`。
> - **例5**： `parseInt`里面有两个参数，第二个参数是5，表示要将`五进制`的123转化为十进制，结果为38 => (`1*5^2 + 2*5^1 + 3*5^0 = 38`)



2、向上取整，有小数就整数部分加1：

```js
// 11.1取整后得到12；
// -11.1取整后得到-11。
Math.ceil(d);
```

3、向下取整，正数舍弃小数位，负数整数位减一：

```
11.1取整后得到11；

-11.1取整后得到-12。

Math.floor(d);
```

4、四舍五入：

```
Math.round(d);
```



## 2.数组转字符串、字符串转数组（√）

### 一、数组转字符串（3种方法）

同样是数组转字符串，toString()，toLocaleString()，join()，join(’,’)的区别是什么？

JavaScript 允许数组与字符串之间相互转换。其中 Array 方法对象定义了 3 个方法，可以把数组转换为字符串，如表所示。

| 数组方法         | 说明                               |
| ---------------- | ---------------------------------- |
| toString()       | 将数组转换成一个字符串             |
| toLocaleString() | 把数组转换成本地约定的字符串       |
| join()           | 将数组元素连接起来以构建一个字符串 |

**1. join()方法用于把数组中的所有元素放入一个字符串**

元素是通过指定的分隔符进行分隔的

| join()指定的分隔符                          | 说明                                                         |
| ------------------------------------------- | ------------------------------------------------------------ |
| join()                                      | 可理解为直接变成字符串，默认逗号分隔                         |
| join(''）                                   | 空连接                                                       |
| join(’ ，’)或者 join(’ - ‘)或者 join(’ 。’) | 中间这个逗号是手动添加的，也可以改成别的比如、。! -等等都可以 |

**2. toString()方法可把一个逻辑值转换为字符串，并返回结果**

```js
var arr = [10, 20, 30, 40];
var str = arr.toString(); //把数组转换为字符串
console.log(str);
console.log(typeof str); //返回字符串string，说明是字符串类型
// 输出：
// 10,true,30,40
// string
```

toString()方法不可以指定分隔符，但是我们可以通过replace()方法指定替换

```js
var str = arr.toString().replace(/,/gi, "-");
console.log(str); // 10-true-30-40
```

**3. toLocaleString()**：把数组转换成本地约定的字符串

```
var arr = [10, true, 30, 40];
var str = arr.toLocaleString(); //把数组转换为字符串
console.log(str); // 10,true,30,40
console.log(typeof str); //返回字符串string，说明是字符串类型

```

### 二、字符串转数组（2种方法）

| 字符串方法      | 说明                   |
| --------------- | ---------------------- |
| split() 方法    | 将字符串转换成一个数组 |
| 扩展运算符（…） | es6里面的扩展运算符    |

**1.split() 方法用于把一个字符串分割成字符串数组**

同样是用于把一个字符串分割成字符串数组，split(’,’)，split()，split(''）的区别是什么？

| split()方法        | 说明                   |
| ------------------ | ---------------------- |
| split(",")         | 以逗号分隔的转换为数组 |
| split(''）空字符串 | 每个字符之间都会被分割 |
| split()            | 可理解为直接变成数组   |

```js
var str = "aa, bb, cc, dd";
var str1 = str.split(",");
var str2 = str.split("");
var str3 = str.split();
console.log(str1); // [ 'aa', ' bb', ' cc', ' dd' ]
console.log(str2); // ['a', 'a', ',', ' ','b', 'b', ',', ' ','c', 'c', ',', ' ','d', 'd']
console.log(str3); // [ 'aa, bb, cc, dd' ]
```

**2.扩展运算符**

```js
var str = "aa,bb,cc,dd";
var str1 = [...str];
console.log(str1); // ['a', 'a', ',', 'b','b', ',', 'c', 'c',',', 'd', 'd']
```



## 3.数组常用方法（√）

### 一、改变原数组的方法7个

总结：

push、pop、unshift、shift、sort、reverse、splice

join、concat、slice、indexOf、lastIndexOf

新增：forEach、map、filter、every、some、reduce、find、Array.from、includes

**1.push()末尾添加数据**

**语法:** **数组名.push(** **数据)**

**作用:** 就是往数组末尾添加数据

**返回值:** 就是这个数组的长度

```js
var arr = [10, 20, 30, 40]
res = arr.push(20)
console.log(arr);//[10,20,30,40,20]
console.log(res);//5
```

**2.pop() 末尾处删除数据**

**语法:** **数组名.pop()**

**作用:** 就是从数组的末尾删除一个数据

**返回值:** 就是你删除的那个数据

```js
var arr = [10, 20, 30, 40] 
res =arr.pop()
console.log(arr);//[10,20,30]
console.log(res);//40
```

**3.unshift() 头部添加数据**

**语法:** **数组名.unshift(** **数据)**

**作用:**  就是在数组的头部添加数据

**返回值:** 就是数组的长度

```js
var arr = [10, 20, 30, 40]
 res=arr.unshift(99)
 console.log(arr);//[99,10,20,30,40]
 console.log(res);//5
```

**4.shift()头部删除数据**

**语法:** **数组名.shift()**

**作用:**  头部删除一个数据

**返回值:**  就是删除掉的那个数据

```//shift
//shift复制代码 var arr = [10, 20, 30, 40]
 res=arr.shift()
 console.log(arr);[20,30,40]
 console.log(res);10
```

**5.reverse() 翻转数组**

**语法:** **数组名.reverse()**

**作用:** 就是用来翻转数组的

**返回值:** 就是翻转好的数组

```//reverse
//reverse复制代码var arr = [10, 20, 30, 40]
res=arr.reverse()
console.log(arr);//[40,30,20,10]
console.log(res);//[40,30,20,10]
```

**6.sort() 排序**

**语法一**: 数组名.sort()   会排序，会按照位排序

**语法二**: 数组名.sort(function (a,b) {return a-b})  会正序排列

**语法三**: 数组名.sort(function (a,b) {return b-a})  会倒序排列

```js
var arr = [2, 63, 48, 5, 4, 75, 69, 11, 23]
arr.sort()
console.log(arr); // [ 11, 2, 23, 4, 48, 5, 63, 69, 75]
arr.sort(function(a,b){return(a-b)})
console.log(arr); // [2,  4,  5, 11, 23, 48, 63, 69, 75     ]
arr.sort(function(a,b){return(b-a)})
console.log(arr); // [75, 69, 63, 48, 23, 11,  5,  4,  2]
```

**7.splice()  截取数组**

**语法一**: 数组名.splice(开始索引,多少个)

​	作用: 就是用来截取数组的

​	返回值: 是一个新数组 里面就是你截取出来的数据

**语法二**: 数组名.splice(开始索引,多少个,你要插入的数据)

​	作用: 删除并插入数据

​	注意: 从你的开始索引起

​	返回值: 是一个新数组 里面就是你截取出来的数据

```//splice()
var arr = [2, 63, 48, 5, 4, 75]
res = arr.splice(1,2)
console.log(arr); // [ 2, 5, 4, 75 ]
console.log(res); // [ 63, 48 ]
//******************************
//splice() 语法二
var arr = [2, 63, 48, 5, 4, 75]
res = arr.splice(1,1,99999,88888)
console.log(arr); // [2, 99999, 88888, 48, 5, 4, 75]
console.log(res); // [ 63 ]
```

### 二、不改变原数组的方法5个

**1.concat() 合并数组**

**语法:** **数组名.concat(** **数据)**

**作用:**  合并数组的

**返回值:**  一个新的数组

```js
var arr = [10, 20, 10, 30, 40, 50, 60]
res = arr.concat(20,"小敏",50)
console.log(arr); // [10, 20, 10, 30, 40, 50, 60]
console.log(res); // [10, 20, 10, 30, 40, 50, 60, 20,"小敏",50]
```

**2.join()  数组转字符串**

**语法:** **数组名.join('****连接符')**

**作用:** 就是把一个数组转成字符串

**返回值:**  就是转好的一个字符串

```js
var arr = [10, 20, 10, 30, 40, 50, 60]
res = arr.join("+")
console.log(arr); // var arr = [10, 20, 10, 30, 40, 50, 60]
console.log(res); // 10+20+10+30+40+50+60
```

**3.slice() 截取数组的一部分数据**

**语法:** **数组名.slice(** **开始索引,** **结束索引)**

**作用:** 就是截取数组中的一部分数据

**返回值:** 就是截取出来的数据 放到一个新的数组中

**注意:** 包前不好后 包含开始索引不包含结束索引

```//slice
var arr = [10, 20, 10, 30, 40, 50, 60]
res = arr.slice(1,4)
console.log(arr); // [10, 20, 10, 30, 40, 50, 60]
console.log(res); // [20, 10, 30]
```

**4.indexOf() 从左检查数组中有没有这个数值**

**语法一:** **数组名.indexOf(要查询的数据)**

**作用:** 就是检查这个数组中有没有该数据，如果有就返回该数据**第一次**出现的索引，如果没有返回 -1

**语法二:** **数组名.indexOf(要查询的数据, 开始索引)**

```//indexOf
var arr = [10, 20, 10, 30, 40, 50, 60]
res = arr.indexOf(10)
console.log(arr); // [10, 20, 10, 30, 40, 50, 60]
console.log(res); // 0
//*************************************
//indexOf  语法二
var arr = [10, 20, 10, 30, 40, 50, 60]
res = arr.indexOf(10,1)
console.log(arr); // [10, 20, 10, 30, 40, 50, 60]
console.log(res); // 2
```

**5.lastIndexOf() 从右检查数组中有没有这个数值**

**语法一:** **数组名.indexOf(** **要查询的数据)**

**作用:** 就是检查这个数组中有没有该数据

如果有就返回该数据**第一次**出现的索引

如果没有返回 -1

**语法二:** **数组名.lastIndexOf(** **要查询的数据,** **开始索引)**

```//lastIndexOf
var arr = [10, 20, 10, 30, 40, 50, 60]
res = arr.lastIndexOf(50)
console.log(arr) 
console.log(res);
//*************************************
//lastIndexOf 语法二
var arr = [10, 20, 10, 30, 40, 50, 60]
res = arr.lastIndexOf(50,4)
console.log(arr)
console.log(res);
```

### 三、ES6新增的数组方法7个（都不改变原数组）

**1. forEach()  用来循环遍历数组**

**语法**: 数组名.forEach(function (item,index,arr) {})

- item : 这个表示的是数组中的每一项
- index : 这个表示的是每一项对应的索引
- arr : 这个表示的是原数组

**作用**: 就是用来循环遍历数组的 代替了我们的for

```//forEach
var arr = [1, 2, 3, 4, 5]
var res = arr.forEach(function (item, index, arr) {
    console.log(item, "------", index, "-------", arr);
})
// 输出：
// 1 ------ 0 ------- [ 1, 2, 3, 4, 5 ]
// 2 ------ 1 ------- [ 1, 2, 3, 4, 5 ]
// 3 ------ 2 ------- [ 1, 2, 3, 4, 5 ]
// 4 ------ 3 ------- [ 1, 2, 3, 4, 5 ]
// 5 ------ 4 ------- [ 1, 2, 3, 4, 5 ]
```

**2.map()  映射数组**

**语法:** 数组名.map(function (item,index,arr) {})

- item : 这个表示的是数组中的每一项
- index : 这个表示的是每一项对应的索引
- arr : 这个表示的是原数组

**作用**: 就是用来数组映射

**返回值:** 必然是一个映射完毕的数组；这个数组和原数组长度一样，不改变原数组

```js
var arr = [1, 2, 3, 4, 5]
var res = arr.map(function (item) {
    return item*1000
})
console.log(arr);
console.log(res);
// 返回值：
// [ 1, 2, 3, 4, 5 ]
// [ 1000, 2000, 3000, 4000, 5000 ]
```

**3.filter()  过滤数组**

**语法**: 数组名.filter(function (item,index,arr) {})

- item : 这个表示的是数组中的每一项
- index : 这个表示的是每一项对应的索引
- arr : 这个表示的是原数组

**作用**: 用来过滤数组的

**返回值**: 如果有就是过滤(筛选)出来的数据 保存在一个数组中；如果没有返回一个空数组

```//filter
var arr = [1, 2, 3, 4, 5]
var res = arr.filter(function (item) {
    return item > 2
})
console.log(arr);
console.log(res);
// 返回值：
// [ 1, 2, 3, 4, 5 ]
// [ 3, 4, 5 ]
```

**4.every()  判断数组是不是满足所有条件**

**语法**: 数组名.every(function (item,index,arr) {})

- item : 这个表示的是数组中的每一项
- index : 这个表示的是每一项对应的索引
- arr : 这个表示的是原数组

**作用**: 主要是用来判断数组中是不是 每一个 都满足条件。只有所有的都满足条件返回的是true，只要有一个不满足返回的就是false

**返回值**: 是一个布尔值 

**注意**: 要以return的形式执行返回条件

```//every
//every复制代码var arr = [1, 2, 3, 4, 5]
var res = arr.every(function (item) {
    return item > 0
})
console.log(res);//打印结果  true
```

**5.some() 数组中有没有满足条件的**

**语法**: 数组名.some(function (item,index,arr) {})

- item : 这个表示的是数组中的每一项
- index : 这个表示的是每一项对应的索引
- arr : 这个表示的是原数组

**作用**: 主要是用来判断数组中是不是 每一个 都满足条件。只有有一个满足条件返回的是true，只要都不满足返回的就是false

**返回值**: 是一个布尔值

**注意**: 要以return的形式执行返回条件

```//some
var arr = [1, 2, 3, 4, 5]
var res = arr.some(function (item) {
    return item > 3
})
console.log(res); //true
```

**6.find() 用来获取数组中满足条件的第一个数据**

**语法**: 数组名.find(function (item,index,arr) {})

- item : 这个表示的是数组中的每一项
- index : 这个表示的是每一项对应的索引
- arr : 这个表示的是原数组

**作用**: 用来获取数组中满足条件的数据

**返回值**: 如果有 就是满足条件的第一个数据；如果没有就是undefined

**注意**: 要以return的形式执行返回条件

```//find
var arr = [1, 2, 3, 4, 5]
var res = arr.find(function (item) {
    return item > 3
})
console.log(res) //4
```

**7.reduce() 累加后的效果**

**语法**: 数组名.reduce(function (prev,item,index,arr) {},初始值)

- prev :一开始就是初始值 当第一次有了结果以后；这个值就是第一次的结果
- item : 这个表示的是数组中的每一项
- index : 这个表示的是每一项对应的索引
- arr : 这个表示的是原数组

**作用**: 就是用来累加的

**返回值**: 就是累加后的结果

**注意**: 以return的形式书写返回条件

```js
var arr = [1, 2, 3, 4, 5]
var res = arr.reduce(function (prev, item) {
    return prev *= item
}, 1)
console.log(res); //120
```

**8.`Array.from()`**

`Array.from()`方法可以将可迭代对象转换为新的数组。

- 函数可接受3个参数（后两个参数可以没有）：
  - 第一个表示将被转换的可迭代对象(如果只有一个参数就是把形参转变成数组)
  - 第二个是回调函数，将对每个数组元素应用该回调函数，然后返回新的值到新数组，
  - 第三个是回调函数内this的指向。

```js
let arr = [1, 2, 3];
let obj = {
    double(n) {
        return n * 2;
    }
}
console.log(Array.from(arr, function (n){
    return this.double(n);
}, obj)); // [2, 4, 6]
```



9.`includes()` 

参数：数值 -------- 返回值：`true/false`

`includes()`方法------是查看数组中是否存在这个元素，存在就返回true,不存在就返回false

```js
let arr = [1,33,44,22,6,9]
let ary = arr.includes(22)
console.log(ary)
```



## 4.深拷贝和浅拷贝、赋值（√）

**其他问法**：数组深拷贝方法

参考：[前端面试 第三篇 js之路 深拷贝与浅拷贝 - 掘金 (juejin.cn)](https://juejin.cn/post/7134970746580762637?searchId=20230903212139B6B7DB5B5E108D8F55BD)、[JavaScript深拷贝和浅拷贝看这篇就够了 - 掘金 (juejin.cn)](https://juejin.cn/post/6994453856063062053#heading-6)、[前端数组、对象的浅拷贝和深拷贝 - 掘金 (juejin.cn)](https://juejin.cn/post/7020348927643746312)、[浅拷贝与深拷贝 - 掘金 (juejin.cn)](https://juejin.cn/post/6844904197595332622)

**深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。**

**浅拷贝**: ① 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。② 如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以**如果其中一个对象改变了这个地址里的内容，就会影响到另一个对象**。（只是拷贝了指针，使得两个指针指向同一个地址，这样在对象块结束，调用函数析构的时，会造成同一份资源析构2次，即delete同一块内存2次，造成程序崩溃）；

<p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/715c839f767d41dc98669788c9705772~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=634&h=277&s=82226&e=png&b=fdf9f8" alt="image.png"  width="50%"/></p>

**深拷贝**: ① 创建一个新对象，将原始对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象，新旧对象不共享同一块内存，且修改新对象不会影响原对象（深拷贝采用了在堆内存中申请新的空间来存储数据，这样可以避免指针悬挂）

<p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5058d13e4a548a3b40e0ae074ffbb92~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=634&h=373&s=84518&e=png&b=fefdfd" alt="image.png"  width="50%"/></p>

【默认情况下基本数据类型（number，string，null，undefined，boolean）都是深拷贝。】

<font color=red>**赋值和深/浅拷贝的区别**</font>，比较的前提都是**针对引用类型**：

- 当我们把一个对象赋值给一个新的变量时，**赋的其实是该对象在栈中的地址，而不是堆中的数据**。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。
- 浅拷贝：重新在堆中创建内存，拷贝前后对象的基本数据类型互不影响，但拷贝前后对象的引用类型因共享同一块内存，会相互影响。
- 深拷贝：从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝，拷贝前后的两个对象互不影响。

<table>
	<tr>
        <th  colspan=4 align="center">对原始数据的影响</th>
    </tr>
    <tr>
        <th width=100px bgcolor=skyblue></th>
        <th bgcolor=skyblue>和原数据是否指向同一对象</th>
        <th bgcolor=skyblue>第一层数据为基本数据类型</th>
        <th bgcolor=skyblue>原数据包含子对象（引用数据类型）</th>
    </tr>
    <tr>
        <td>赋值</td>
        <td>是</td>
        <td>赋值后的数据改变，<strong><mark>会</mark></strong>使原数据一同改变</td>
        <td>赋值后的数据改变，<strong><mark>会</mark></strong>使原数据一同改变</td>
    </tr>
    <tr>
        <td>浅拷贝</td>
        <td>否</td>
        <td>浅拷贝后的数据改变，<strong><mark>不会</mark></strong>使原数据一同改变</td>
        <td>浅拷贝后的数据改变，<strong><mark>会</mark></strong>使原数据一同改变</td>
    </tr>
    <tr>
        <td>深拷贝</td>
        <td>否</td>
        <td>浅拷贝后的数据改变，<strong><mark>不会</mark></strong>使原数据一同改变</td>
        <td>浅拷贝后的数据改变，<strong><mark>不会</mark></strong>使原数据一同改变</td>
    </tr>
</table>


举例：

```
// 对象赋值
let obj1 = {
 name: "Chen",
 age: 18,
 hobby: ["see a film", "write the code", "play basketball", "tourism"],
};
let obj2 = obj1;
obj2.name = "Forever";
obj2.hobby[1] = "swim";
obj2.hobby[2] = "alpinism";
console.log("obj1===>", obj1);
console.log("obj2===>", obj2);
// 输出为：
obj1===> {
  name: 'Forever',
  age: 18,
  hobby: [ 'see a film', 'swim', 'alpinism', 'tourism' ]
}
obj2===> {
  name: 'Forever',
  age: 18,
  hobby: [ 'see a film', 'swim', 'alpinism', 'tourism' ]
}
// 结论：对象中基本属性和引用属性都发生改变
```

```js
// 浅拷贝
let obj1 = {
 name: "Chen",
 age: 18,
 hobby: ["see a film", "write the code", "play basketball", "tourism"],
};
let obj3 = { ...obj1 };
obj3.name = "Forever";
obj3.hobby[1] = "swim";
obj3.hobby[2] = "alpinism";
console.log("obj1===>", obj1);
console.log("obj3===>", obj3);
// 输出为：
obj1===> {
  name: 'Chen',
  age: 18,
  hobby: [ 'see a film', 'swim', 'alpinism', 'tourism' ]
}
obj3===> {
  name: 'Forever',
  age: 18,
  hobby: [ 'see a film', 'swim', 'alpinism', 'tourism' ]
}
// 结论：浅拷贝时，对象中基本属性不变，引用属性发生变化
```

**注意：当拷贝对象只有一层的时候，是深拷贝**



### 浅拷贝的实现

1. **Object.assign()**

参考资料：[Object.assign()基本用法、注意点、用法](https://juejin.cn/post/6844903984675684366)

`Object.assign()` 方法用于将所有可枚举属性的值从一个或多个源对象`source`复制到目标对象。

**参数：**第一个参数是目标对象，后面的参数都是源对象。

**返回：**目标对象`target`。

```js
const target = { a: 1, b: 2 }
const source = { b: 4, c: 5 }
const returnedTarget = Object.assign(target, source)
target 			// { a: 1, b: 4, c: 5 }
returnedTarget  // { a: 1, b: 4, c: 5 }
```

**注意**：

-  如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。

-  如果只有一个参数，`Object.assign`会直接返回该参数。

-  如果该参数不是对象，则会先转成对象，然后返回。由于`undefined`和`null`无法转成对象，所以如果它们作为第一个参数，就会报错。如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果`undefined`和`null`不在首参数，就不会报错。其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，<u>除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</u>

   ```
   let obj = {a: 1}
   Object.assign(obj, undefined) === obj // true
   Object.assign(obj, null) === obj 	  // true
   
   const v1 = 'abc'
   const v2 = true
   const v3 = 10
   const obj = Object.assign({}, v1, v2, v3)
   obj // { "0": "a", "1": "b", "2": "c" }
   ```

-  `Object.assign`拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（`enumerable: false`）。



数组的处理 `Object.assign`可以用来处理数组，但是会把数组视为对象。

```js
Object.assign([1, 2, 3], [4, 5])	// [4, 5, 3]
```

上面代码中，`Object.assign`把数组视为属性名为 `0、1、2` 的对象，因此源数组的 `0` 号属性`4`覆盖了目标数组的 `0` 号属性`1`。

2. **函数库lodash的_.clone方法**

该函数库也有提供_.clone用来做浅拷贝，后面我们会再介绍利用这个库实现深拷贝。

```js
var _ = require('lodash');
var obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};
var obj2 = _.clone(obj1);
console.log(obj1.b.f === obj2.b.f);// true
```

3. **扩展运算符...**

提供了一种非常方便的方式来执行浅拷贝，这与 Object.assign ()的功能相同。

```js
let obj1 = { name: 'Kobe', address:{x:100,y:100}}
let obj2= {... obj1}
obj1.address.x = 200;
obj1.name = 'wade'
console.log('obj2',obj2) // obj2 { name: 'Kobe', address: { x: 200, y: 100 } }
```

4. **Array.prototype.concat()**

```js
let arr = [1, 3, {
    username: 'kobe'
    }];
let arr2 = arr.concat();    
arr2[2].username = 'wade';
console.log(arr); //[ 1, 3, { username: 'wade' } ]
```

5. **Array.prototype.slice()**

```js
let arr = [1, 3, {
    username: ' kobe'
    }];
let arr3 = arr.slice();
arr3[2].username = 'wade'
console.log(arr); // [ 1, 3, { username: 'wade' } ]
```



### 深拷贝的实现：

1. **JSON.parse(JSON.stringify())**

利用`JSON.stringify`将对象转成JSON字符串，再用`JSON.parse`把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。

2. **函数库lodash的_.cloneDeep方法**

```js
var _ = require('lodash');
var obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};
var obj2 = _.cloneDeep(obj1);
console.log(obj1.b.f === obj2.b.f);// false
```

3. **jQuery.extend()方法**

jquery 有提供一個`$.extend`可以用来做 Deep Copy

```js
$.extend(deepCopy, target, object1, [objectN])  	//第一个参数为true,就是深拷贝

var $ = require('jquery');
var obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};
var obj2 = $.extend(true, {}, obj1);
console.log(obj1.b.f === obj2.b.f); // false

```

4. **手写递归方法**

递归方法实现深度拷贝原理：**遍历 对象或数组 直到里边都是基本数据类型，然后再去复制，就是深度拷贝**。

有种特殊情况需注意就是对象存在**循环引用**的情况，即对象的属性直接的引用了自身的情况，解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。关于这块如有疑惑，请仔细阅读`ConardLi大佬`[如何写出一个惊艳面试官的深拷贝?](https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000020255831)这篇文章。

```javascript
function deepClone(obj, hash = new WeakMap()) {
  if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);
  // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝
  if (typeof obj !== "object") return obj;
  // 是对象的话就要进行深拷贝
  if (hash.get(obj)) return hash.get(obj);
  let cloneObj = new obj.constructor();
  // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身
  hash.set(obj, cloneObj);
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      // 实现一个递归拷贝
      cloneObj[key] = deepClone(obj[key], hash);
    }
  }
  return cloneObj;
}
let obj = { name: 1, address: { x: 100 } };
obj.o = obj; // 对象存在循环引用的情况
let d = deepClone(obj);
obj.address.x = 200;
console.log(d);
```



数组实现深拷贝可以使用以下方法

- 使用`slice()`
- 使用`concat()`
- ES6扩展运算符[...str]
- Array.from()

## 5.手写深拷贝函数 （√）

这里写了三种，参考资料：[手写深浅拷贝](https://juejin.cn/post/7264208575974834231?searchId=20230904153935A317FD4976A2592BDE92#heading-8)

1. 简单版（JSON）

```js
let a = {
    age: 1,
    jobs: {
        first: 'FE'
    }
}
let b = JSON.parse(JSON.stringify(a))
a.jobs.first = 'native'
console.log(b.jobs.first) // FE
```

2. 基础版（手写递归）

下面是一个实现 `deepClone` 函数封装的例子，通过 `for in` 遍历传入参数的属性值，如果值是引用类型则再次递归调用该函数，如果是基础数据类型就直接复制

```js
let obj1 = {
  a:{
    b:1
  }
}
function deepClone(obj) { 
  let cloneObj = {}
  for(let key in obj) {                 //遍历
    if(typeof obj[key] ==='object') { 
      cloneObj[key] = deepClone(obj[key])  //是对象就再次调用该函数递归
    } else {
      cloneObj[key] = obj[key]  //基本类型的话直接复制值
    }
  }
  return cloneObj
}
let obj2 = deepClone(obj1);
obj1.a.b = 2;
console.log(obj2);   //  {a:{b:1}}
```

3. 进阶版（递归实现）

```js
// 判断一个对象是否为复杂数据类型，即对象或函数类型，且不为 null
const isComplexDataType = obj => (typeof obj === 'object' || typeof obj === 'function') && (obj !== null)

// 定义深拷贝函数 deepClone，接受两个参数：obj 为要进行深拷贝的目标对象，hash 为已经拷贝过的对象的哈希表（用于解决循环引用问题）
const deepClone = function (obj, hash = new WeakMap()) {
  // 1.如果目标对象是日期对象，则直接返回一个新的日期对象，避免修改原日期对象
  if (obj.constructor === Date) {
    return new Date(obj)
  }
  // 2.如果目标对象是正则对象，则直接返回一个新的正则对象，避免修改原正则对象
  if (obj.constructor === RegExp){
    return new RegExp(obj)
  }
  // 3.如果目标对象已经被拷贝过，则从 hash 中获取已经拷贝过的对象并返回，避免出现循环引用问题
  if (hash.has(obj)) {
    return hash.get(obj)
  }
  // 获取目标对象的所有属性描述符
  let allDesc = Object.getOwnPropertyDescriptors(obj)
  // 创建一个新对象 cloneObj，并将其原型链指向 obj 的原型对象
  let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc)
  // 将目标对象和克隆对象的映射关系存入 hash 中，用于解决循环引用问题
  hash.set(obj, cloneObj)
  // 遍历目标对象的所有属性（包括字符串类型和 Symbol 类型的属性名）
  for (let key of Reflect.ownKeys(obj)) { 
    // 如果目标对象的属性值是复杂数据类型（即对象或数组），则递归调用 deepClone 函数进行深拷贝，并将拷贝结果赋值给克隆对象的对应属性
    if (isComplexDataType(obj[key]) && typeof obj[key] !== 'function') {
      cloneObj[key] = deepClone(obj[key], hash)
    } else {
      // 如果目标对象的属性值不是复杂数据类型，则直接将其赋值给克隆对象的对应属性
      cloneObj[key] = obj[key]
    }
  }
  // 返回深拷贝后的新对象
  return cloneObj
}
```



## 6.call、apply、bind的作用和区别？（√）

其他问法：改变this的方法，apply和call最初设计的时候为什么要设计这两个，为什么apply参数是数组call不是

<font color=red>🍀 **call 和 apply**</font>

**作用：**用来改变函数内部 `this` 的指向。

**特点：**

- 任何函数都可以调用这两个方法，说明它们是添加在函数原型上的方法（`Function.prototype`）。
- 调用 `call` 和 `apply` 的函数会立即执行。`call` 和 `apply` 的返回值就是函数的返回值。
- 调用 `call` 和 `apply` 指向 `undefined` 或者 `null` ，会将 `this` 指向 `window`。
- 调用 `call` 和 `apply` 指向一个值类型， 会将 `this` 指向由它们的构造函数创建的实例。
- 调用 `call` 和 `apply` 指向一个引用类型， 会将 `this` 指向这个对象。

**call 和 apply的区别**

除了传参的形式不同没什么区别，传给`fn`的参数写法不同：

- `call` 接收多个参数，第一个为函数上下文也就是 `this` ，后边参数为函数本身的参数。
- `apply` 接收两个参数，第一个参数为函数上下文 `this`，第二个参数为函数参数只不过是通过一个 **数组** 的形式传入的。

<font color=red>🍀 **bind**</font>

**作用**：也是用来改变函数内部 `this` 的指向。

**bind 和 call/apply 的区别**：

**1. 是否立刻执行**：

- `call/apply` 改变了函数的 `this` 上下文后 **马上** 执行该函数。
- `bind` 则是返回改变了上下文后的函数，**不执行该函数** 。

**2. 返回值的区别**:

- `call/apply` 返回函数。
- `bind` 返回函数的拷贝，指定了 函数 的 `this` 指向，保存了函数的参数。



## 7.轮播图实现思路 （√）

实现前端轮播图（也称为轮播幻灯片或轮播广告）通常涉及以下主要步骤和思路：

1. **HTML结构：** 首先，在HTML中创建轮播图的基本结构。通常会使用一个包含图像或内容的容器，并为每个轮播项创建一个子元素。

```html
<div class="carousel">
  <div class="carousel-item">
    <!-- 内容或图像1 -->
  </div>
  <div class="carousel-item">
    <!-- 内容或图像2 -->
  </div>
  <!-- 更多轮播项 -->
</div>
```

2. **CSS样式：** 使用CSS样式来定义轮播图容器的外观，包括宽度、高度、位置等。还可以设置轮播项的布局和过渡效果。

```css
.carousel {
  width: 100%;
  overflow: hidden;
  position: relative;
}
.carousel-item {
  width: 100%;
  display: none; /* 隐藏所有项，除了当前活动的项 */
  transition: opacity 1s; /* 过渡效果 */
}
.carousel-item.active {
  display: block; /* 显示当前活动的项 */
}
```

3. **JavaScript交互：** 使用JavaScript来实现轮播图的交互逻辑。以下是一些常见的实现思路：
   - **自动播放：** 设置定时器，以一定的时间间隔自动切换到下一张轮播项。
   - **手动控制：** 添加前进和后退按钮，以允许用户手动浏览轮播项。
   - **指示器：** 创建轮播指示器，以显示当前轮播项的位置，并允许用户通过点击指示器来切换轮播项。
   - **循环播放：** 当到达最后一张轮播项时，循环回到第一张。
   - **响应式设计：** 确保轮播图在不同屏幕尺寸下适应，并且图像大小和数量能够自动调整。

```js
let currentSlide = 0;
const slides = document.querySelectorAll('.carousel-item');

function showSlide(index) {
  slides[currentSlide].classList.remove('active');
  slides[index].classList.add('active');
  currentSlide = index;
}

function nextSlide() {
  const next = (currentSlide + 1) % slides.length;
  showSlide(next);
}

function prevSlide() {
  const prev = (currentSlide - 1 + slides.length) % slides.length;
  showSlide(prev);
}

// 自动播放
setInterval(nextSlide, 5000);

// 手动控制按钮
const nextButton = document.getElementById('next-button');
const prevButton = document.getElementById('prev-button');

nextButton.addEventListener('click', nextSlide);
prevButton.addEventListener('click', prevSlide);
```

**优化和性能：** 对于包含大量图像的轮播图，应考虑性能优化，如懒加载图像，压缩图像大小等。



## 8.闭包的原理，有哪些应用？（√）

要理解闭包，首先必须理解Javascript特殊的变量作用域。变量的作用域无非就是两种：全局变量和局部变量。

- 闭包是指函数和它所引用的外部变量之间的关联关系。当一个函数内部引用了外部的变量时，即使这个函数执行完毕，那些外部变量仍然可以被访问。这是因为 JavaScript 中的函数不仅包含代码，还包含了执行上下文，其中包括了函数内部引用的外部变量。

- 当一个函数嵌套在另一个函数内部时，内部函数可以访问外部函数的变量。如果内部函数在外部函数执行完后仍然存在，并引用了外部函数的变量，那么就形成了一个闭包。这样，外部函数的变量不会被销毁，而是继续存在于内部函数的作用域中。

**闭包的应用**：

1. **封装和模块化**：闭包可以用于创建私有变量和函数，使其不被外部访问，将相关的功能封装在一个函数内部，只暴露必要的接口给外部,从而实现封装和模块化的代码结构。

   ```js
   function createCounter() {
     let count = 0;
     return function () {
       return ++count;
     };
   }
   
   const counter = createCounter();
   console.log(counter()); // 1
   console.log(counter()); // 2
   ```

**2,保存状态**：闭包可以用于保存函数执行时的状态，例如计数器、事件处理等。

```js
function createCounter() {
  let count = 0;
  return function () {
    return ++count;
  };
}
const counterA = createCounter();
const counterB = createCounter();
console.log(counterA()); // 1
console.log(counterB()); // 1
console.log(counterA()); // 2
```

**3.函数柯里化**：闭包可以用于函数柯里化，将一个多参数函数转化为一系列单参数函数。

```js
function add(x) {
  return function (y) {
    return x + y;
  };
}

const addFive = add(5);
console.log(addFive(3)); // 8
```

**4.回调函数**：在异步编程中，常常会使用闭包来处理回调函数，以保持上下文和访问相关的数据。

```js
function fetchData(url, callback) {
  // 异步操作获取数据
  setTimeout(() => {
    const data = "Some data from " + url;
    callback(data);
  }, 1000);
}

fetchData("https://example.com", function(data) {
  console.log(data);
});
```

**事件处理**：DOM 事件处理函数常常使用闭包来访问事件发生时的上下文信息。

```js
function addClickHandler(element) {
  element.addEventListener("click", function() {
    console.log("Clicked element: " + element.id);
  });
}
const button1 = document.getElementById("button1");
const button2 = document.getElementById("button2");
addClickHandler(button1);
addClickHandler(button2);
```

**定时器**：在定时器中使用闭包可以保持定时器回调函数对特定数据的访问。

```js
function startTimer() {
  let count = 0;
  const intervalId = setInterval(function() {
    count++;
    console.log("Count: " + count);
    if (count >= 5) {
      clearInterval(intervalId);
    }
  }, 1000);
}

startTimer();
```

总之，闭包是JavaScript中强大而灵活的概念，它在许多方面都有应用，包括封装数据、模块化开发、事件处理、回调函数和定时器等。理解闭包的原理可以帮助你更好地利用它来解决各种编程问题。



但要注意，过度使用闭包可能会导致内存泄漏，因此在使用闭包时需要小心管理内存。



## 9.手写promise



## 10.原型链的理解



## 11.对继承有什么了解吗？有几种方式？优劣？





## 12.对异步编程有什么了解？就回调函数、Promise，async/await，具体的是指什么？



## 13.作用域和作用域链、块级作用域（√）

> 作用域：**全局作用域、函数作用域、块级作用域（ES6出的）

**全局作用域：**

- 全局作用域是整个 JavaScript 程序的最外层作用域。在全局作用域中声明的变量和函数可以在代码的任何地方访问，它们通常被称为全局变量和全局函数。全局作用域在整个应用程序的生命周期中存在，直到应用程序关闭或页面刷新为止。

- 全局作用域有一个全局对象windom，它代表的是一个浏览器的窗口，它由浏览器创建，我们可以直接使用
- 在全局作用域中：创建的变量都会作为window对象的属性，创建的方法都会作为windom的方法

**函数作用域：**

- 函数作用域是在函数内部声明的变量和函数所拥有的作用域。这意味着在函数内声明的变量只能在该函数内部访问，外部的代码无法直接访问这些变量。这有助于封装变量，防止命名冲突，并提高代码的可维护性。

- 调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁。每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的。在函数作用域中可以访问到全局作用域的变量。
- 在全局作用域中无法访问到函数作用域的变量。当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用如果没有则向上一级作用域中寻找，直到找到全局作用域。如果全局作用域中依然没有找到，则会报错ReferenceError。
- 在函数中要访问全局变量可以使用window对象。

**块级作用域（Block Scope）**：

- 块级作用域是在 JavaScript ES6（ECMAScript 2015）引入的新概念。它使得变量在 `{ }` 块内部声明时具有局部作用域，而不再仅限于函数作用域。块级作用域通常与 `let` 和 `const` 关键字一起使用。这有助于更细粒度地控制变量的作用域
- `if` 语句和 `for` 语句里面的 `{ }` 也属于块作用域。

**1. 作用**：

1. **变量封装和隔离：** 作用域允许你将变量和函数封装在一个特定的区域内，以防止命名冲突和不必要的全局污染。这意味着你可以在不同的作用域中定义具有相同名称的变量或函数而不会相互干扰。
2. **变量可见性：** 作用域定义了变量在代码中的可见范围。在一个作用域内声明的变量只能在该作用域内访问，而不能在外部作用域访问。这有助于控制变量的访问权限，防止不必要的外部访问和修改。
3. **生命周期管理：** 作用域还控制了变量的生命周期，即它们存在的时间段。在离开作用域时，作用域内的变量通常会被销毁，从而释放内存资源。这有助于减少内存泄漏和提高代码的性能。
4. **作用域链：** 作用域链是一种嵌套的结构，允许内部作用域访问外部作用域中的变量。这种机制使得函数能够访问其定义范围之外的变量，如闭包（closure）中的概念。
5. **代码组织和模块化：** 作用域有助于将代码模块化，使得代码更易于组织、维护和重用。你可以将相关的变量和函数放在同一个作用域中，以创建更清晰和可维护的代码结构。

总之，作用域是一种关键的编程概念，它提供了变量和函数的可见性和隔离，有助于管理变量的生命周期，同时也支持了一些高级的编程模式，如闭包。通过正确使用作用域，你可以编写更健壮、可维护和可扩展的代码。

**2. （不算块级作用域）有多少个作用域**：n+1原则，n表示定义了几个函数，1表示全局作用域

**3. 作用域和执行上下文的区别：**

- 区别1：
  - 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时。
  - 全局执行上下文环境是在全局作用域确定之后，js代码马上执行之前创建的
  - 函数执行上下文环境是在调用函数时，函数体代码执行之前创建
- 区别2：
  - 作用域是静态的，只要函数定义好了就一直存在，且不会再变化
  - 上下文环境是动态的，调用函数时创建，函数调用结束时上下文环境就会被释放
- 联系
  - 上下文环境（对象）是从属于所在的作用域的
  - 全局上下文环境==》全局作用域
  - 函数上下文环境==》对应的函数作用域

> 作用域链

**1.理解：**多个上下级关系的作用域形成的链，它的方向是从内到外的。查找变量时就是沿着作用域链来查找的。

**2.查找一个变量的查找规则：**

- 在当前作用域下的执行上下文中查找对应的属性，如果有则返回，否则进入2；
- 在上一级作用域的执行上下文中查找对应的属性，如果有则返回，否则进行3；
- 再次执行2的相同操作，直到全局作用域，如果还是找不到就抛出找不到的异常。

> 块级作用域

引入块级作用域的主要原因是提高 JavaScript 代码的可维护性、可读性和安全性。以下是引入块级作用域的一些重要原因：

1. **避免变量污染（Variable Pollution）：** 在传统的函数作用域中，变量通常是函数级别的，这意味着在函数内部声明的变量在整个函数内都可见，容易导致变量污染问题，特别是在嵌套函数中。块级作用域允许我们在更小的范围内声明变量，避免了不必要的变量冲突。
2. **更安全的代码：** 块级作用域使得变量的作用范围更加明确和受限。这有助于减少意外的变量重写和不必要的副作用。在块级作用域内声明的变量仅在块内部可见，而不会泄漏到外部作用域。
3. **更好的内存管理：** 在块级作用域中声明的变量拥有更短的生命周期。一旦块执行结束，这些变量就会被销毁，从而帮助更有效地管理内存。这对于避免内存泄漏问题非常有帮助。
4. **可读性和可维护性：** 使用块级作用域可以更清晰地表达变量的作用范围，使代码更容易理解和维护。这对于大型项目和团队协作特别有价值。
5. **解决闭包问题：** 在传统函数作用域中，闭包可能会导致一些意外的问题，因为函数作用域的变量在整个函数范围内可见。块级作用域可以减少闭包问题的出现。

引入块级作用域的方式是使用 `let` 和 `const` 关键字来声明变量，它们具有块级作用域，而不是像 `var` 一样具有函数作用域。这样的改进使得 JavaScript 代码更加可控和可预测，有助于提高代码质量和安全性。

## 14.事件循环（√）

**其他问法：**给一段代码，事件循环结果输出是什么

事件循环的动画演示：[浏览器EventLoop事件循环机制动画演示_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1RW4y147Xv/?spm_id_from=333.337.search-card.all.click&vd_source=94d2cdd20c6d4a2ab076b4fda45b3865)

JS是一个单线程的动态解释性语言，需要通过JS的[引擎(JS Engine)](https://zh.wikipedia.org/wiki/JavaScript引擎)进行解释(翻译)成对应的字节码、机器码然后才会运行。随着网页复杂性和性能要求的提高，JS引擎也经历了从[SpiderMonkey](https://zh.wikipedia.org/wiki/SpiderMonkey)到[V8(由google开发)](https://v8.dev/)的变革，而由谷歌开发的V8引擎最为出色，目前已被大多数现代浏览器等(Chrome、Edge、Safari)采用。同时JS也从以前浏览器单一的运行时(Runtime)演变到可以在服务端运行的NodeJS(基于V8)运行时，为它提供不同平台的运行时环境。

- **Runtime**：由JavaScript的宿主环境提供额外的属性和方法，如浏览器提供了用户交互和一些异步任务的功能。
- **Engine**：为JavaScript解析和执行提供环境条件(类似Java虚拟机)，并完成内存分配和垃圾回收等等。

JS的是通过异步回调的方式解决单线程的执行阻塞问题，虽然JS引擎是单线程的，但它的宿主环境一般都是多线程的，如通过浏览器的定时任务线程、网络线程协调执行异步回调。所以常说的EventLoop是面向宿主环境的也就是Runtime，如浏览器和NodeJS。EventLoop主要是宿主环境实现的

这里我们需要先了解下浏览器的架构，本文以Chrome浏览器作为介绍：

它是多进程和多线程的架构，其内部包括：

- Brower进程：提供浏览器URL、后退/前进、调度等全局作用
- 网络进程：进行网络资源请求、安全策略等等
- GPU进程：3D渲染、动画绘制等等
- 渲染进程：负责每个Tab页面加载解析，JS、CSS、DOM等相关页面和用户操作
- 插件进程：浏览器插件

除了以上列出的进程外，还有一些其它的进程。

这里主要来说下**渲染进程**，它是前端开发者最必要的关注点。Chrome为每个tab页面提供一个渲染进程。渲染进程会包括很多线程：

1. 主线程：调度页面的加载解析，执行dom、css、js操作处理等等
2. GUI线程：负责页面的渲染
3. JS引擎线程：进行解析执行JS
4. 定时器线程：处理异步定时任务
5. 异步请求线程：进行网络请求
6. 事件触发线程：监听执行事件callback
7. WebWorker线程：独立的脚本，不影响页面渲染，通常用来执行密集复杂的计算

等等...

当加载页面时会从上到下解析文档，当遇到JS脚本(通常情况下)时会阻塞DOM的解析，也就是JS引擎的执行会阻塞GUI线程渲染的执行，这也符合JS是个单线程语言的特征。不过渲染进程也提供了不同的线程去处理异步任务，可以并行处理多个任务，如：定时器线程、网络请求线程等等，而不会影响页面的渲染推翻JS单线程的理念。

其实浏览器多线程执行异步任务的原理背后是基于事件驱动机制的。不同类型的事件触发不同的任务，如：点击事件、滚动事件等等。而事件循环机制(EventLoop)就是基于事件驱动机制的。当JS执行代码时，如果遇到异步代码如Ajax请求时，会交给别的线程去执行异步任务，然后主线程挂起当前任务，不会阻塞后面代码的执行。这些异步任务会由浏览器不同的线程进行负责，不会影响到主线程和JS引擎线程，当这些异步任务执行完毕后，会被存放到指定的任务队列中，等JS的执行栈中当前同步任务执行完毕后，会从这些任务队列中取出待执行的任务，而具体优先取哪一个这就是要取决于事件循环机制了。

**通过上面的介绍你应该会了解到浏览器的多线程其实就是让JS拥有多线程并发处理异步任务的能力，主要负责点击等事件、定时任务、网络请求、脚本执行、用户交互和页面渲染之间的的调度。**



JS的运行机制就是事件循环！事件循环（Event Loop）是一种处理异步操作的编程模型，通常在单线程的环境中使用，如浏览器的JavaScript引擎或Node.js。事件循环允许程序执行异步任务，而不会阻塞主线程，以确保应用程序的响应性和性能。



1. **事件循环的基本原理**：
   - 事件循环是一个持续运行的循环，它不断检查任务队列（Task Queue）中是否有待处理的任务。
   - 任务可以是回调函数，例如定时器回调、事件处理器或Promise的`then`回调。
   - 当任务队列中有任务时，事件循环将逐个执行这些任务，并将它们从队列中移除。
2. **事件循环的组成部分**：
   - **调用栈（Call Stack）**：用于执行同步代码，每个函数调用都会在栈上创建一个帧，帧中包含了 函数 的参数和局部变量。
   - **任务队列（Task Queue）**：用于存储待处理的异步任务，包括宏任务（如setTimeout）和微任务（如Promise）。所以任务队列里有宏任务队列和微任务队列。
   - **事件触发线程**：用于监听外部事件，例如鼠标点击或HTTP请求，将相关任务推送到任务队列中。（也可以理解为web APIs）
3. **事件循环的执行流程**：
   - 从调用栈开始，执行同步代码。
   - 遇到异步任务（宏任务或微任务），会委托给宿主环境执行。已完成的异步任务对应的回调函数，会被加入到任务队列中等待执行。
   - 继续执行同步代码，直到调用栈为空。
   - 从任务队列中取任务，如果有微任务则先执行微任务，然后在执行宏任务，直到任务队列为空。
   - 重复上述步骤。

**当主线程中的执行栈被清空后，JS主线程会从任务队列中读取异步任务的回调函数，放在执行栈中依次执行。这个过程是循环不断的，所以整个的这种运行机制又被称为EventLoop(事件循环)。**

易错点：

1. 如果是定时器任务，则会在宿主环境执行了定时器的时间之后再加入宏任务队列。比如设置1s，则会在1s后加入到宏任务队列；
2. promise本身是一个同步的代码(只是容器)，只有它后面调用的then()方法里面的回调才是微任务
3. await右边的表达式还是会立即执行,表达式之后的代码才是微任务, await微任务可以转换成等价的promise微任务分析
4. script标签本身是一个`宏任务`， 当页面出现多个script标签的时候，浏览器会把script标签作为宏任务来解析

参考：[EventLoop事件循环机制(浏览器和Node EventLoop) ](https://blog.usword.cn/frontend/js/eventloop.html)、[事件循环机制（Event Loop）的基本认知 - 掘金 (juejin.cn)](https://juejin.cn/post/6962806212660297758)

## 15.宏任务和微任务（√）

**先来了解一下三个重要的概念**：**主线程**、**微任务(micro task)**、**宏任务(macro task)**

**主线程**

所有的同步任务都是在主线程里执行的，异步任务可能会在`macrotask`或者`microtask`里面

- **同步任务：** 指的是在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。
- **异步任务：** 指的是不进入主线程，某个异步任务可以执行了，该任务才会进入主线程执行。

**微任务(micro task)**

- promise：promise本身是一个同步的代码(只是容器)，只有它后面调用的then()方法里面的回调才是微任务
- async/await：await右边的表达式还是会立即执行,表达式之后的代码才是微任务
- process.nextTick(node)
- mutationObserver(html5新特性)

**宏任务(macro task)**

- script(整体代码)：script标签本身是一个`宏任务`， 当页面出现多个script标签的时候，浏览器会把script标签作为宏任务来解析
- setTimeout、setInterval
- setImmediate
- I/O（输入输出）
- UI render
- ajax
- (DOM操作)： 如没有阻塞的插入元素
- 读取文件
- navigation和history：导航和history操作
- 常见的键盘、鼠标、Ajax、setTimeout、setInterval、操作数据库等都属于MacroTask Source

【注意】

- 微任务是由ES6语法规定的
- 宏任务是由浏览器规定的

- 微任务在DOM渲染前触发，宏任务在DOM渲染后触发

在EventLoop中的每一次循环成一个`tick`，每一次tick都会先执行同步任务，然后查看是否有微任务，将所有的微任务在这个阶段执行完，如果执行微任务阶段再次产生微任务也会把他执行完（每次tick只会有一个微任务队列），接下来会可能会进行视图的渲染，然后再从MacroTask队列中选择一个合适的任务放入执行栈执行，然后重复前面的步骤不断循环

参考资料：[事件循环机制（Event Loop）的基本认知 - 掘金 (juejin.cn)](https://juejin.cn/post/6962806212660297758)

## 16.对象的遍历（√）


要遍历对象中的键值对，你可以使用不同的方法，具体取决于你的需求和 JavaScript 的版本。以下是两种常见的遍历对象键值对的方法：

1. **使用 for...in 循环**（适用于普通对象）：

   ```js
   const myObject = { a: 1, b: 2, c: 3 };
   
   for (const key in myObject) {
     if (myObject.hasOwnProperty(key)) {
       const value = myObject[key];
       console.log(key + ": " + value);
     }
   }
   ```

   请注意，使用 `hasOwnProperty` 来检查属性是否属于对象是为了确保不会遍历到原型链上的属性。

2. **使用 Object.keys() 和 forEach()**（适用于普通对象）：

   ```js
   const myObject = { a: 1, b: 2, c: 3 };
   
   Object.keys(myObject).forEach((key) => {
     const value = myObject[key];
     console.log(key + ": " + value);
   });
   ```

   这种方法使用 `Object.keys()` 获取对象的所有键，然后使用 `forEach()` 方法遍历键，以访问相应的值。

3. **使用 for...of 循环**（适用于 ES6 中的 Map 和 Set，以及可迭代对象）：

   ```js
   const myMap = new Map();
   myMap.set("a", 1);
   myMap.set("b", 2);
   myMap.set("c", 3);
   
   for (const [key, value] of myMap) {
     console.log(key + ": " + value);
   }
   ```

   这种方法适用于 Map、Set 和其他可迭代对象，它允许直接在循环中获取键和值。



1 实习内容介绍，你们的分页怎么实现，假如不给你total值，你可以实现分页吗，你觉得一个分页组件的核心要素是什么（有没有佬解答一下）
7渲染10w条数据怎么优化，虚拟列表技术上怎么实现，闪烁怎么解决
8常见性能优化手段
9假如用户打开了你的网站，但是是白屏你怎么解决
10说一下hashmap，常见数据结构
12nodejs有没有接触
13你对前端的看法，你更想做前端的哪个方向



# 📚 ES6

## 1.ES6模块化





## 2.Promise（√）

Promise 是 JavaScript 中用于处理异步操作的对象。它提供了一种更结构化和可管理的方式来处理异步代码，以避免回调地狱（Callback Hell）和提高代码的可读性。

**异步操作有哪些？**异步操作是指在程序执行过程中不会等待某个任务完成而是继续执行其他任务的一种编程模式。在计算机编程中，有许多情况下需要进行异步操作，以下是一些常见的异步操作的示例：

1. **网络请求**：从服务器获取数据通常需要一段时间，因此在发起网络请求后，通常会继续执行其他任务，而不会等待数据返回。
2. **文件读写**：读取大文件或者写入文件都可能需要花费一定时间，因此通常以异步方式执行。
3. **定时任务**：设置定时器执行某个任务，例如在一段时间后触发回调函数。
4. **事件处理**：监听事件，例如点击事件、键盘事件、鼠标事件等，当事件发生时执行相关的回调函数。
5. **数据库操作**：连接数据库、查询数据、写入数据等数据库操作通常是异步的。
6. **动画和多媒体处理**：在网页开发中，动画和多媒体处理通常需要异步执行，以确保界面流畅性。
7. **Promise 和异步函数**：使用 JavaScript 中的 Promise 和异步函数（`async/await`）来管理和处理异步操作。
8. **并发任务**：同时执行多个任务，例如并发下载多个文件。
9. **外部设备交互**：与外部硬件设备（例如传感器、摄像头、打印机等）通信通常是异步的。
10. **用户输入**：等待用户输入数据，例如等待用户填写表单或选择选项。

异步操作是现代计算机编程中不可或缺的部分，因为它们允许程序在等待某些任务完成时继续执行其他任务，从而提高了程序的响应性和性能。在异步编程中，通常使用回调函数、Promise、异步函数（`async/await`）等机制来处理异步操作，以确保正确的执行顺序和错误处理。



以下是 Promise 的详细介绍：

**1.Promise 的状态**：

- Promise 有三种状态：`pending`（进行中）、`fulfilled`（已成功）、`rejected`（已失败）。
- 当一个异步操作开始时，Promise 处于 `pending` 状态。
- 当操作成功完成时，Promise 会从 `pending` 转变为 `fulfilled`，并传递一个结果值。
- 当操作发生错误时，Promise 会从 `pending` 转变为 `rejected`，并传递一个拒绝原因。

**2.Promise 的基本结构**：

```js
const myPromise = new Promise((resolve, reject) => {
  // 异步操作，根据结果调用 resolve 或 reject
  if (/* 操作成功 */) {
    resolve(result); // 成功时调用 resolve 并传递结果
  } else {
    reject(error); // 失败时调用 reject 并传递错误信息
  }
});
```

**3.Promise 的方法**：

- `.then(onFulfilled, onRejected)`: 用于注册回调函数，当 Promise 进入 `fulfilled` 状态时，调用 `onFulfilled`，当进入 `rejected` 状态时，调用 `onRejected`。
- `.catch(onRejected)`: 用于捕获 Promise 的错误，相当于 `.then(null, onRejected)`。
- `.finally(onFinally)`: 无论 Promise 的状态如何，都会执行 `onFinally` 回调，通常用于清理工作。
- `.all(iterable)`: 接受一个可迭代对象（通常是数组），并在所有 Promise 都成功时返回一个新的 Promise，如果其中任何一个失败，则返回的 Promise 失败。
- `.race(iterable)`: 接受一个可迭代对象，并返回一个新的 Promise，当其中任何一个 Promise 成功或失败时，返回的 Promise 也相应地成功或失败。

**4.实例**

```js
const fetchData = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const randomNum = Math.random();
      if (randomNum > 0.5) {
        resolve(randomNum); // 模拟成功
      } else {
        reject("Error"); // 模拟失败
      }
    }, 1000);
  });
};

fetchData()
  .then((result) => {
    console.log("Success:", result);
  })
  .catch((error) => {
    console.error("Error:", error);
  })
  .finally(() => {
    console.log("Cleanup");
  });

```

Promise 是处理异步代码的一种强大工具，它使得异步操作更具可读性和可维护性。但要注意，Promise 本身不处理多个异步操作之间的依赖关系，这时可以结合使用 `Promise.all` 或其他异步控制工具来处理。

**5.promise的优点**

Promise 在处理异步操作时具有许多优点，其中一些主要优点包括：

1. **可读性和可维护性**：Promise 提供了一种结构化的方式来处理异步代码，通过链式调用 `.then()` 和 `.catch()` 方法，可以更清晰地表达代码的逻辑，减少了回调地狱（Callback Hell）的问题，使代码更易于理解和维护。
2. **错误处理**：Promise 具备良好的错误处理机制。你可以使用 `.catch()` 方法捕获 Promise 中的错误，这使得错误处理更加一致和可控。
3. **顺序控制**：Promise 允许你按照特定的顺序执行异步操作，而不需要深度嵌套回调函数。这使得代码的执行流程更容易理解，特别是在复杂的异步场景中。
4. **并行执行**：使用 `Promise.all()`，你可以并行执行多个异步操作，并在它们都完成后获得结果。这提高了性能，特别是在需要同时发起多个请求的情况下。
5. **可组合性**：Promise 非常容易组合，你可以将多个 Promise 链接在一起以执行复杂的异步任务，这种可组合性有助于构建模块化和可重用的异步代码。
6. **更好的错误跟踪**：由于 Promise 具有状态和错误处理机制，因此当出现问题时，可以更轻松地跟踪错误的来源和上下文，有助于快速诊断和修复问题。
7. **标准化**：Promise 是一种标准的异步处理方法，已被广泛采纳并集成到 JavaScript 和许多库和框架中。这意味着开发者可以在不同的环境中共享和理解 Promise 代码。
8. **异步代码的统一接口**：Promise 提供了一种统一的接口，不论是处理异步的浏览器 API、Node.js 回调风格的函数，还是其他异步操作，都可以很容易地包装成 Promise，使得异步操作的处理方式更加一致。

总之，Promise 是一种强大的工具，它提供了更好的异步编程体验，使得异步代码更易于编写、理解和维护，并提供了一种标准化的方式来处理异步操作。这些优点有助于改善代码质量和开发效率。

**6.promise实现按照特定的顺序执行异步操作**

要按照特定顺序执行异步操作，你可以使用 Promise 的链式调用方法 `.then()` 来实现。每个 `.then()` 方法返回一个新的 Promise，可以用来处理前一个操作的结果，并在其中触发下一个异步操作。以下是一个示例，演示了如何按照特定顺序执行异步操作：

```js
javascriptCopy code// 模拟异步操作，返回一个 Promise
function asyncOperation(order, delay) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log(`Operation ${order} completed`);
      resolve(order); // 模拟操作成功，传递订单号
    }, delay);
  });
}

// 按照特定顺序执行异步操作
asyncOperation(1, 1000)
  .then((result) => {
    return asyncOperation(2, 2000); // 等第一个操作完成后执行第二个操作
  })
  .then((result) => {
    return asyncOperation(3, 500); // 等第二个操作完成后执行第三个操作
  })
  .then((result) => {
    console.log("All operations completed");
  })
  .catch((error) => {
    console.error("Error:", error); // 捕获任何操作中的错误
  });
```

在上面的示例中，`asyncOperation` 函数模拟了异步操作，每个操作都有一个延迟时间。通过使用 `.then()` 方法，我们确保每个操作在前一个操作完成后才执行，从而按照特定顺序执行这些异步操作。

这种方法允许你构建异步操作的串行流程，确保它们按照你的期望顺序执行。如果任何一个操作失败，你也可以使用 `.catch()` 方法捕获错误。

**7.promise的应用场景**

Promise 在 JavaScript 中有广泛的使用场景，特别是在处理异步操作时，它们非常有用。以下是一些常见的 Promise 使用场景：

**1. 网络请求**：当你需要从服务器获取数据时，通常会使用 Promise。这可以包括使用 `fetch` API 或其他库（如 Axios）来执行 HTTP 请求。

```js
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error(error));
```

**2. 定时任务**：使用 `setTimeout` 或 `setInterval` 进行定时任务，通常结合 Promise 使用，以便在一定时间后执行某个操作。

```js
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

delay(2000) // 等待 2 秒
  .then(() => console.log('2 秒后执行的任务'));
```

**3. 文件操作**：读取和写入文件通常是异步操作，Promises 也用于处理这些操作。

```js
javascriptCopy codeconst fs = require('fs');

function readFileAsync(path) {
  return new Promise((resolve, reject) => {
    fs.readFile(path, 'utf8', (err, data) => {
      if (err) {
        reject(err);
      } else {
        resolve(data);
      }
    });
  });
}

readFileAsync('file.txt')
  .then(data => console.log(data))
  .catch(error => console.error(error));
```

**4.并行执行多个任务**：`Promise.all` 可用于并行执行多个异步任务，并等待它们全部完成。

```
javascriptCopy codeconst promises = [fetchData1(), fetchData2(), fetchData3()];

Promise.all(promises)
  .then(results => console.log(results))
  .catch(error => console.error(error));
```

**5.处理事件**：Promises 可以用于封装事件处理，以便在事件发生时执行异步操作。

```
javascriptCopy codeconst button = document.getElementById('myButton');

function onClick() {
  return new Promise((resolve) => {
    button.addEventListener('click', resolve, { once: true });
  });
}

onClick()
  .then(() => console.log('按钮被点击了'));
```

这些是一些常见的 Promise 使用场景，但实际上 Promises 可以用于几乎任何需要处理异步操作的情况。它们提供了一种更结构化和可管理的方式来处理异步代码，有助于提高代码的可读性和可维护性。



## 3.ES6、ES7、ES8、ES9、ES10新特性一览（√）

以下是一些 JavaScript 的主要 ECMAScript（ES）版本（ES6 到 ES10）中引入的新特性和改进：

1. ES6（ECMAScript 2015）：
   - 函数：箭头函数、参数默认值。
   - `let` 和 `const`：块级作用域变量声明。
   - symbol
   - 类：引入了类和面向对象编程的支持。
   - 模板字面量：字符串模板。
   - 解构赋值：数组解构、对象解构。
   - 剩余和扩展操作符：`...` 运算符用于处理可变数量的参数。
   - Promise：更好的异步编程支持。
   - 模块化：引入了 `import` 和 `export` 以支持模块化编程。
   - 对象：map和set、属性名简写、对象和数组新方法
2. ES7（ECMAScript 2016）：
   - Array.prototype.includes()：用于检查数组是否包含某个元素的方法。
3. ES8（ECMAScript 2017）：
   - `async` 和 `await`：用于更简单的异步代码编写。
   - Object.values() 和 Object.entries()：用于遍历对象的值和键值对。
   - 字符串填充：`padStart()` 和 `padEnd()` 用于填充字符串。
4. ES9（ECMAScript 2018）：
   - 异步迭代器和 `for-await-of` 循环：更好的异步迭代支持。
   - Rest/Spread 属性：在对象上使用 `...` 运算符。
   - 正则表达式增强：引入 `s` 修饰符以匹配换行符，并且支持命名捕获组。
5. ES10（ECMAScript 2019）：
   - Array.prototype.flat() 和 Array.prototype.flatMap()：用于处理多维数组的新方法。
   - Object.fromEntries()：将键值对数组转换为对象。
   - `String.prototype.trimStart()` 和 `String.prototype.trimEnd()`：去除字符串开头和结尾的空白字符。
   - 动态 `import()`：异步加载模块。
   - 可选链式调用（Optional Chaining）：安全地访问深层嵌套对象的属性。
   - 空值合并运算符（Nullish Coalescing）：处理 `null` 和 `undefined` 值的默认值问题。

每个新版本都引入了一些语言特性和语法改进，以提高 JavaScript 的功能和可读性，并简化开发人员的工作。



## 4.变量和函数的声明提前（√）

**1.变量：**使用`var`关键字定义的变量会在所有代码执行之前被声明，但是不会赋值。

**2.函数：**使用函数声明形式创建的函数function 函数名{} 会在所有代码执行之前被创建，所以我们可以在函数声明前来调用函数，使用函数表达式创建的函数不会声明提升。

**3.函数作用域也有声明提升的特性：**

- 使用var关键字声明的变量，会在函数中所有的代码执行之前被声明。
- 函数声明也会在函数中所有代码执行之前执行。

> **注意：**
>
> ①在函数中不使用var声明的变量都会变成全局变量
>
> ②定义形参相当于在函数作用域中声明了变量



## 5.let、const、var三者的区别（√）

我们在全局作用域中或局部作用域中，使用`var`关键字声明的变量，**都会被提升到该作用域的最顶部**，这就是我们常说的变量提升

`let`, `const`, 和 `var` 是 JavaScript 中用于声明变量的关键字，它们之间有一些重要的区别：

1. **作用域：**
   - `let` 和 `const` 声明的变量具有块级作用域（在 `{}` 内有效），是es6语法新提出的，不会变量提升。
   - `var` 声明的变量是**函数级作用域**的（在函数内有效），并且会变量提升至函数的顶部。（即使写在if代码块里也是看函数作用域的）
2. **变量提升：**
   - `var` 声明的变量会被提升到函数或全局作用域的顶部，即使在声明之前访问它，也不会报错，但值为 `undefined`。
   - `let` 和 `const` 声明的变量没有变量提升，在访问之前会存在暂时性死区（Temporal Dead Zone，TDZ），访问时会报错，表示该变量存在但不可访问的状态。
3. **重复声明：**
   - 使用 `var` 可以多次声明同名变量，而不会抛出错误。
   - 使用 `let` 或 `const` 在同一作用域内重复声明同名变量会引发语法错误。
4. **可变性：**
   - `var` 声明的变量可以重新赋值，也可以不赋值。
   - `let` 声明的变量可以重新赋值，但不可以不赋值。
   - `const` 声明的变量必须在声明时初始化，并且不能重新赋值。
5. **全局对象属性：**
   - 使用 `var` 声明的全局变量会成为全局对象（例如，`window` 在浏览器中）的属性。
   - 使用 `let` 或 `const` 声明的全局变量不会成为全局对象的属性。
6. **适用场景：**
   - 推荐使用 `let` 或 `const`，因为它们更安全，避免了许多常见的问题，特别是 `const` 对于不需要重新赋值的情况。
   - 在需要支持旧版浏览器或在一些特定情况下，仍然可以使用 `var`。

总结来说，`let` 和 `const` 是现代 JavaScript 推荐的变量声明方式，它们提供了更严格的作用域和变量行为，有助于减少错误。在编写新的代码时，应优先使用 `let` 和 `const`，只有在特殊情况下才使用 `var`。



## 6.async/await（√）

`async/await` 是 JavaScript 中用于处理异步操作的语法糖，它们使得异步代码的编写和阅读更加清晰和直观。`async` 用于定义一个异步函数，而 `await` 用于等待一个异步操作完成。以下是关于 `async/await` 的详细解释以及如何使用它们：

**async 函数**：

- `async` 是一个关键字，用于定义一个异步函数，它在函数前面添加 `async` 关键字来表示这个函数将返回一个 Promise。

```js
async function fetchData() {
  // 异步操作
  return result;
}
```

**await 表达式**：

- `await` 也是一个关键字，用于等待一个 Promise 完成并返回其结果。它只能在 `async` 函数内部使用。

```js
async function example() {
  const result = await fetchData(); // 等待 fetchData() 异步操作完成
  console.log(result);
}
```

**async/await 的作用**：

1. **改善异步代码的可读性**：`async/await` 可以将异步操作的嵌套回调转化为更线性的代码，使得代码更容易理解。
2. **更好的错误处理**：`try/catch` 结合 `await` 可以更容易地捕获和处理异步操作中的错误，提高了代码的可维护性。
3. **等待异步操作完成**：`await` 让你可以等待异步操作的结果，而不需要回调函数或 Promise 的 `.then()` 方法来处理结果。

**如何使用 async/await**：

**1. 定义异步函数**：首先，使用 `async` 关键字定义一个异步函数。

```js
javascriptCopy codeasync function fetchUserData() {
  // 异步操作
}
```

**2. 在函数内使用 await**：在函数内部，使用 `await` 关键字等待一个异步操作的完成。这个异步操作通常是返回一个 Promise 的函数调用。

```js
async function fetchUserData() {
  const response = await fetch('https://api.example.com/userdata');
  const data = await response.json();
  return data;
}
```

**3. 调用异步函数**：在其他地方调用异步函数时，可以使用 `.then()` 来处理 Promise 的结果，或者将其包装在另一个异步函数中并使用 `await`。

```js
fetchUserData()
  .then((userData) => {
    console.log(userData);
  })
  .catch((error) => {
    console.error(error);
  });

// 或者使用 async/await
async function main() {
  try {
    const userData = await fetchUserData();
    console.log(userData);
  } catch (error) {
    console.error(error);
  }
}

main();
```

`async/await` 是一种强大的工具，可以显著提高异步代码的可读性和可维护性，使得异步编程更加愉快和容易。但请注意，`async/await` 只能在支持 ECMAScript 2017（ES8）及更高版本的 JavaScript 环境中使用。



## 7.map 和 set （√）

Map对象用于保存键值对，任何值JavaScript支持的值都可以作为一个键（key）或者一个值（value）。 与对象不同的是

1. object的键只能是**字符串**或ES6的**symbol**值，而Map可以是任何值。
2. Map对象有一个**size属性**，存储了键值对的个数，而object对象没有类似属性。

> <font color=red>**Map介绍如下**</font>

`Map` 是一种键值对的集合，其中每个值都有一个相关联的键。以下是关于 `Map` 的详细介绍和使用方法：

**特性和用途**：

- 键可以是任意数据类型，包括对象、函数和原始数据类型。
- 保持键值对的插入顺序，因此可以迭代它们的顺序。
- 可以使用 `size` 属性来获取 `Map` 中键值对的数量。
- `Map` 是一种灵活的数据结构，适用于许多不同的场景，例如缓存、数据存储等。

**创建和基本操作**：

```js
// 创建一个空的 Map
const myMap = new Map();
// 设置键值对
myMap.set('name', 'John');
myMap.set('age', 30);
// 获取值
console.log(myMap.get('name')); // 输出: "John"
// 检查是否包含某个键
console.log(myMap.has('age')); // 输出: true
// 删除键值对
myMap.delete('age');
// 迭代 Map
myMap.forEach((value, key) => {
  console.log(key, value);
});
// 清除所有的键值对
myMap.clear();
```

> <font color=red>**Set**</font>

`Set` 是一种 值的无序集合，其中每个值都是唯一的，不能重复。以下是关于 `Set` 的详细介绍和使用方法：

**特性和用途**：

- 存储唯一的值，去重效果非常高效。
- 不允许重复的元素，因此不能有相同值的项。
- 可以使用 `size` 属性来获取 `Set` 中值的数量。
- `Set` 通常用于存储一组不重复的值，例如集合操作、去重数组等。

**创建和基本操作**：

```js
// 创建一个空的 Set
const mySet = new Set();
// 添加值
mySet.add(1);
mySet.add(2);
mySet.add(2); // 不会重复添加
// 检查是否包含某个值
console.log(mySet.has(2)); // 输出: true
// 删除值
mySet.delete(1);
// 迭代 Set
mySet.forEach((value) => {
  console.log(value);
});
// 清除所有的键值对
mySet.clear();
```

总之，`Map` 适用于需要存储键值对的情况，而 `Set` 适用于需要存储一组唯一值的情况。这两种数据结构在 JavaScript 中提供了更多的灵活性和高效性，可以用于解决各种问题。

<table>
    <tr>
        <th>两者的比较</th>
        <th>map</th>
        <th>set</th>
    </tr>
    <tr>
        <td>创建一个空的</td>
        <td>const myMap = new Map();</td>
        <td>const mySet = new Set();</td>
    </tr>
    <tr>
        <td>添加</td>
        <td>myMap.set('name', 'John');</td>
        <td>mySet.add(1);</td>
    </tr>
    <tr>
        <td>获取</td>
        <td>myMap.get('name')</td>
        <td>--</td>
    </tr>
    <tr>
        <td>判断是否有某值</td>
        <td>myMap.has('age')，返回布尔值</td>
        <td>mySet.has(2)，返回布尔值</td>
    </tr>
    <tr>
        <td>删除单个键值对</td>
        <td>myMap.delete('age');</td>
        <td>mySet.delete(1);</td>
    </tr>
    <tr>
        <td>清除所有</td>
        <td>myMap.clear();</td>
        <td>mySet.clear();</td>
    </tr>
</table>

## **8.对象的新方法**（√）

在 ES6 中，添加了`Object.is()`、`Object.assign()`、`Object.keys()`、`Object.values()`、`Object.entries()`等方法。

**1. Object.is()**

- `Object.is()`方法用来判断两个值是否为同一个值，返回一个布尔类型的值。

```js
const obj1 = {};
const obj2 = {};
console.log(Object.is(obj1, obj2)); // false

const obj3 = {};
const value1 = obj3;
const value2 = obj4;
console.log(Object.is(value1, value2)); // true
```

**2. Object.assign()**

- `Object.assign()`方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象，并返回目标对象。

```js
const obj1 = { a: 1 };
const obj2 = { b: 2 };
const obj3 = { a:5 , c: 3 };
//对象合并，把后面对像合并到第一个对象，对象里相同的属性会覆盖
Object.assign(obj1, obj2, obj3);
console.log(obj1); // { a: 5, b: 2 , c:3}
```

**3.Object.keys()、Object.values()、Object.entries()**

- Object.keys()  返回对象所有属性
- Object.values() 返回对象所有属性值
- Object.entries() 返回多个数组，每个数组是 key--value 不解释直接看例子

```js
let person = {
    name: "admin",
    age: 12,
    language: ["java", "js", "css"],
};
console.log(Object.keys(person)); //[ 'name', 'age', 'language' ]
console.log(Object.values(person)); //[ 'admin', 12, [ 'java', 'js', 'css' ] ]
console.log(Object.entries(person));    /* [
                                                     ["name", "admin"],
                                                     ["age", 12],
                                                     ["language", ["java", "js", "css"]],
	                                           ]; */
```



# 📚 浏览器

## 1.浏览器缓存（强缓存，协商缓存）具体字段头是哪些，有何区别





## 2.前端缓存方法



## 3.输入URL到页面渲染的过程



## 4.同源策略和跨域



# 📚 计算机网络

## 1.介绍一下Http各个版本









# 📚 性能优化

## 1.防抖和节流的实现方式



## 2.图片懒加载



# 📚 vue2+vue3

## 1.Vue diff算法（√）

Vue.js 使用了一种称为Virtual DOM（虚拟DOM）的机制来提高页面渲染的性能。Vue的Virtual DOM通过Diff算法来比较前后两个虚拟DOM树的差异，然后仅更新需要变化的部分，从而减少了页面重绘和重新渲染的开销。以下是Vue的Diff算法的简要工作原理：

1. **生成虚拟DOM树：** 当数据发生变化时，Vue首先会生成一个新的虚拟DOM树。这个虚拟DOM树是一个JavaScript对象树，它的结构与实际的DOM树相似，但只包含了需要渲染的元素和组件。
2. **比较新旧虚拟DOM树：** Vue会逐层比较新旧虚拟DOM树的节点，找出差异。这个比较过程是深度优先的，从根节点开始，递归地比较子节点。
3. **标记差异：** 在比较的过程中，Vue会标记出两个虚拟DOM树之间的差异。差异可以分为四种类型：添加、删除、属性修改和文本内容修改。
4. **批量更新：** 一旦标记出差异，Vue会将所有差异记录下来，然后一次性地应用这些差异，而不是立即更新实际的DOM。这个批量更新可以提高性能，因为实际的DOM操作是昂贵的。
5. **更新视图：** 最后，Vue会使用新的虚拟DOM树来更新实际的DOM，只更新那些发生变化的部分。这个过程通常是非常高效的，因为它只涉及到实际变化的部分，而不是整个页面。

Vue的Diff算法的性能优化是通过减少实际DOM操作的次数来实现的，这是因为实际DOM操作是相对较慢的，尤其是在复杂的页面上。通过比较虚拟DOM树并只更新需要变化的部分，Vue能够显著提高页面的性能和响应速度。

需要注意的是，Vue的Diff算法并不是唯一的实现方式，不同的前端框架可能使用不同的Diff算法来提高性能。但Diff算法的核心思想是相似的：通过比较前后两个状态来确定需要更新的部分，从而减少不必要的DOM操作。

## 2.Vue组件通信

包括父子组件通信：父传子，子传父，兄弟组件通信





## 3.闭包在vue中有哪些应用？（√）

以下是一些常见的 Vue.js 中闭包的应用场景：

**1.事件处理函数**：当你在 Vue 组件中绑定事件处理函数时，这些函数通常会捕获组件的作用域（即组件的数据和方法）。这是因为事件处理函数被绑定在组件实例上，形成了一个闭包，使得它们可以访问组件的数据和方法。

```vue
<template>
  <button @click="handleClick">点击我</button>
</template>

<script>
export default {
  data() {
    return {
      count: 0,
    };
  },
  methods: {
    handleClick() {
      // 这里的 this 指向组件实例，可以访问组件的数据
      this.count++;
    },
  },
};
</script>
```

**2.模块化开发**：Vue 组件通常使用单文件组件（.vue 文件）来组织代码，这些文件中的数据、计算属性、方法等都被封装在组件的闭包中，以避免全局污染和命名冲突。

```vue
<script>
export default {
  data() {
    return {
      message: 'Hello, Vue!',
    };
  },
  computed: {
    reversedMessage() {
      return this.message.split('').reverse().join('');
    },
  },
  methods: {
    showMessage() {
      alert(this.message);
    },
  },
};
</script>
```

**3.路由守卫**：在 Vue Router 中，路由守卫使用闭包来访问当前路由的信息、组件实例等，以执行导航守卫逻辑。

```js
import router from './router';
router.beforeEach((to, from, next) => {
  // 访问当前路由的信息
  console.log(to.path);
  // 访问组件实例
  console.log(to.matched[0].instances.default);
  next();
});
```

**4.自定义指令**：如果你编写自定义 Vue 指令，闭包可以用于存储和访问指令的局部状态和逻辑。

```js
Vue.directive('custom-directive', {
  bind(el, binding) {
    // 使用闭包访问局部状态
    let count = 0;

    el.addEventListener('click', () => {
      // 在事件处理程序中使用局部状态
      count++;
      console.log(`Clicked ${count} times`);
    });
  },
});
```

**5.计时器和异步操作**：Vue 中常用的计时器（如 `setInterval`、`setTimeout`）和异步操作（如 AJAX 请求）也会涉及到闭包。你可以在回调函数内部访问组件的数据。

```vue
<script>
export default {
  data() {
    return {
      timer: null,
      message: "Hello, Vue!",
    };
  },
  created() {
    // 使用闭包保存组件内部数据
    this.timer = setInterval(() => {
      console.log(this.message);
    }, 1000);
  },
  destroyed() {
    // 清除计时器以防止内存泄漏
    clearInterval(this.timer);
  },
};
</script>
```

**6.作用域**：在一些特殊情况下，你可能需要在 Vue 模板中使用闭包来访问外部作用域的数据。这通常涉及到在计算属性或指令中使用函数。

```vue
<template>
  <div>
    <p>{{ calculate() }}</p>
    <button @click="updateMessage">更新消息</button>
  </div>
</template>

<script>
export default {
  data() {
    return {
      message: "Hello, Vue!",
    };
  },
  methods: {
    updateMessage() {
      this.message = "New Message";
    },
  },
  computed: {
    calculate() {
      // 使用闭包访问外部作用域的数据
      const originalMessage = this.message;
      return function () {
        return `Length: ${originalMessage.length}`;
      };
    },
  },
};
</script>
```

总之，闭包在 Vue.js 中被广泛用于访问组件的局部作用域、数据和方法，以及实现模块化开发、路由守卫、自定义指令等功能。Vue.js 利用闭包机制使得组件化开发更加强大和灵活。



## 4.vue中双向数据绑定（√）

Vue.js中的双向数据绑定是其核心特性之一，它使视图和模型之间的数据保持同步。Vue的双向绑定原理可以概括为以下几个步骤：

1. **数据劫持（Data Observation）**：
   - 当你在Vue实例中声明数据时，Vue会通过对象的`Object.defineProperty`方法来将这些属性转化为"响应式属性"。
   - Vue会遍历数据对象的每个属性，并在每个属性上定义`getter`和`setter`方法。
   - `getter`负责追踪属性的依赖关系，当属性被读取时，会将观察者添加到依赖项列表中。
   - `setter`监听属性的变化，当属性被修改时，会通知所有依赖于该属性的观察者，并触发视图更新。
2. **模板编译（Template Compilation）**：
   - Vue使用带有特殊语法的模板来定义视图。
   - 模板中的表达式会被解析并建立对数据属性的引用。
   - Vue会将模板编译成虚拟DOM（Virtual DOM）。
3. **虚拟DOM与真实DOM的比较（Virtual DOM Diffing）**：
   - 每当数据发生变化时，Vue会生成一个新的虚拟DOM树。
   - Vue会将新的虚拟DOM与旧的虚拟DOM进行比较，找出两者之间的差异。
   - 这个过程叫做"虚拟DOM的Diff算法"，它可以高效地找出需要更新的部分，以最小化DOM操作。
4. **更新视图（Reactivity）**：
   - Vue知道哪些属性在模板中被引用，以及它们之间的依赖关系。
   - 当数据改变时，Vue会触发相应属性的`setter`方法，通知相关的观察者进行更新。
   - 观察者接收到通知后，会通知虚拟DOM重新渲染视图，但只更新变化的部分，而不是整个视图。
5. **用户交互与数据变更的同步（User Interaction and Data Mutation）**：
   - 当用户与页面交互，例如在表单输入框中输入内容时，输入框的值会被绑定到Vue实例的数据属性。
   - 数据属性的变化将触发更新，更新会反映在视图中，保持视图和数据的同步。

总的来说，Vue的双向绑定原理通过数据劫持、模板编译、虚拟DOM的比较和更新视图等机制，使数据与视图保持同步，从而实现了双向数据绑定。这个机制使得开发者可以更轻松地管理数据和用户界面的交互，提高了开发效率和应用的可维护性。



## 5.Vue 中的虚拟DOM和真实DOM（√）

vue.js 是一个流行的前端 JavaScript 框架，它使用虚拟 DOM（Virtual DOM）来提高性能和效率。理解虚拟 DOM 和真实 DOM 的概念对于理解 Vue.js 和其他一些前端框架的工作原理非常重要。

1. **真实 DOM（Real DOM）**：
   - 真实 DOM 是浏览器中实际存在的文档对象模型。
   - 当页面中的数据发生变化时，浏览器会重新渲染整个页面，包括对应数据发生变化的部分。
   - 操作真实 DOM 需要消耗大量的计算资源，因此频繁的 DOM 操作可能导致性能下降。
2. **虚拟 DOM（Virtual DOM）**：
   - 虚拟 DOM 是一个轻量级的 JavaScript 对象树，它是对真实 DOM 的抽象。
   - 当数据变化时，Vue.js 首先会生成一个新的虚拟 DOM 树，然后将新旧虚拟 DOM 树进行比较，找出差异。
   - 找到差异后，Vue.js 只更新必要的部分，而不是整个页面，以提高性能。
   - 这种方式可以减少对真实 DOM 的操作次数，从而提高应用的性能和响应速度。

虚拟 DOM 的工作流程如下：

1. 初始渲染：Vue.js 使用模板和数据生成虚拟 DOM。
2. 数据变化：当应用状态（数据）发生变化时，Vue.js 生成一个新的虚拟 DOM。
3. 虚拟 DOM 比较：Vue.js 将新旧虚拟 DOM 树进行比较，找出差异。
4. 更新真实 DOM：Vue.js 只更新必要的部分，以使真实 DOM 反映新的应用状态。

虚拟 DOM 的好处在于它可以最小化对真实 DOM 的直接访问和操作，从而提高了前端应用的性能和效率。这是因为真实 DOM 操作通常是昂贵的，而虚拟 DOM 可以将多个操作批量处理并最小化页面的重新渲染。

在使用 Vue.js 时，你通常不需要直接操作虚拟 DOM，框架会负责处理它。你只需关注数据的变化和视图的声明性描述，Vue.js 将自动处理虚拟 DOM 的创建和更新。这使得开发过程更简单，同时又能保持良好的性能。



## 6.vue3和vue2的区别（√）

Vue.js是一个流行的JavaScript框架，用于构建用户界面。Vue 3和Vue 2之间存在一些重要的区别，Vue 3引入了一些新功能和性能优化，以提高开发者的体验。以下是Vue 3和Vue 2之间的主要区别：

1. **性能优化：** Vue 3在性能方面进行了显著改进。其中一个关键的优化是虚拟DOM的升级，使其更高效。Vue 3还引入了懒编译，允许更小的包大小，因此加载时间更快。
2. **Composition API：** Vue 3引入了Composition API，这是一种新的组织组件逻辑的方式。它允许开发者根据功能而不是选项对代码进行组织，使组件更容易理解和维护。
3. **Teleport：** Vue 3引入了Teleport，这是一种新的方式来在DOM中移动元素，而无需改变其组件层次结构。这对于创建模态框、弹出菜单等非常有用。
4. **Fragments：** Vue 3支持Fragments，允许你在组件中返回多个根元素，而不需要包装它们在一个额外的父元素中。
5. **全局API的更改：** Vue 3对一些全局API进行了更改。例如，`Vue.observable()`现在变成了`Vue.reactive()`，`Vue.nextTick()`现在是`Vue.nextTick()`。
6. **自定义渲染器：** Vue 3引入了自定义渲染器的能力，这意味着你可以在不同的目标（例如Web、原生移动应用、桌面应用）上渲染Vue组件。
7. **TypeScript支持：** Vue 3更好地支持TypeScript，包括通过`.d.ts`文件提供类型定义。
8. **模块化编译：** Vue 3的编译器是模块化的，这意味着你可以只编译你实际用到的特性，而不是整个编译器。

需要注意的是，虽然Vue 3引入了许多改进和新功能，但它与Vue 2的核心思想仍然保持一致，因此如果你已经熟悉Vue 2，学习Vue 3应该相对容易。然而，对于新项目，特别是需要性能优化和更好的组织代码的项目，Vue 3通常是更好的选择。





项目用的vue2 问会不会vue3

vue3取消了mixin，用什么代替 
适配是怎么实现的 为啥要适配
采用px-vw不会造成拉伸吗
axios发送的请求如何取消
404要怎么实现
如何在登录前防止用户访问
前后端分离相较前后端不分离的区别
用的什么打包工具 
使用webpack做了什么
webpack如何打包import 
封装过什么组件
对项目提出过什么改进



# 📚 面试题带坑

## 1.console.log(["1", "2", "3"].map(parseInt));的输出值是多少？

来源：[parseInt()函数绝不是你想的那么简单~~ - 掘金 (juejin.cn)](https://juejin.cn/post/7049161354703273998)

【知识点】：map()和parseInt()

【分析】`map`方法可以将一个数组映射为一个新数组。它接收一个`callback`回调函数作为参数，这个回调函数体现了将原数组映射成新数组的映射关系。原数组在循环遍历数组每一项时，都会调用一次`callback`回调函数，并传入三个参数：

- 当前正在遍历的元素
- 元素索引
- 原数组本身 (这个参数基本不使用)

`callback`函数对当前遍历的元素进行包装执行，得到的返回值就是新数组中对应的结果

`parseInt`接收两个参数：

- 第一个参数`string`：要被解析的字符串，如果不是字符串会被转换，忽视空格符
- 第二个参数`radix`：要解析的数字的基数。该值介于`2 ~ 36`之间。默认值为10，表示十进制。这个参数表示**将前面的字符从radix进制转化为十进制**

把上面的代码的完整写法为：

```
console.log(
  ["1", "2", "3"].map(function (item, index, arr) {
    console.log(item + "-----" + index);
    return parseInt(item, index);
  })
);
```

每次每一项给parseInt传入的值为：

```
1-----0
2-----1
3-----2
```

所以最终结果为：[ 1, NaN, NaN ]







其他：

PC端和移动端项目CSS的适配区别
\3. rem是怎么设置的，手动算的还是用了库
\4. rem和em的区别
\5. 屏幕大小变化的时候是如何适配的
\6. 直接写rem计算屏幕的宽高是怎么获取的
\7. 其他移动端适配的方法？
\8. 上一题提示：vw，vh
\9. 逻辑像素和物理像素的区别
\10. 浏览器渲染是如何解析渲染html文档的
\11. css下载的过程会阻塞js的下载吗
\12. 为什么阻塞？
\13. 项目性能优化的方式
\14. tree shaking的限制条件？比如模块化方式commonJS或ES6module的方法能实现吗
\15. 原生JS 类的实现方法，比如new一个函数的过程
\16. ES6的class编译完成后产物是什么样的，比如是函数or对象or数组
\17. 可以用var a = new 
\18. ES6中继承的原理？
\19. 原型链
\20. function的prototype是什么
\21. 闭包原理
\22. ES5有哪些作用域，ES6呢
\23. 项目中用过的异步方法怎么实现的
\24. promise传的参数(resolve，reject)执行时机是异步还是同步的
\25. 函数里有error会怎么样
\26. 必须catch吗，用then呢
\27. then后面再有then，是会进入resolve还是reject的回调
\28. async await原理
\29. await后面跟一个1或者字符串可以吗
\30. Generator函数接触过吗
\31. 浏览器的Eventloop和node的Eventloop区别
\32. 提示：事件循环
\33. 异步任务挂起之后还可以给下一个用户提供服务吗，(挂起期间有新用户访问)
\34. git用到哪些命令多一些
\35. merge用过吗
\36. 跨域问题如何解决
\37. 跨域请求的时候带cookie怎么带
\38. react 了解过吗，如果让你上手做可以做吗
\39. hook听过吗

做题
\1. 最长连续递增数组，复杂度多少，能优化到多少 
\2. 二叉树层数

304状态码是什么，说一下这个请求的过程

详细说下协商缓存

HTTP2.0的多路复用是什么

CSRF是什么

如果是第三方的链接，直接拒绝访问是不是也可以，就是CSRF怎么达到一种攻击的状态，攻击了用户的什么东西

CSRF如何防御

CORS跨域的请求响应过程

origin的请求跨域网站头，能放很多域名吗

以上的流程和细节多学习

Vue的源码

如何监听一个对象属性的改变

浏览器如何解析Vue的模板，最终在浏览器中如何使用

Vue模板会解析成什么样子的东西，又没有了解

Vue的diff算法是什么

写一个div，第一个子元素用v-if控制，如何第一个元素v-if=false，其中的子div会不会塌陷和挤压，结合diff算法来说

技术栈是react和Angluar，写游戏页面里的H5

面完十分钟秒挂，我说要是技术栈和业务方向 学历不匹配可以别面，别浪费彼此时间

webpack 原理？

Tree shaking 的原理？
\- 想用 Tree Shaking 可以有哪些方式？
\- 所有 ES6 写的都可以用 Tree Shaking 吗？
\- Tree Shaking 有哪些限制？
\- 如果我一个导入依赖另一个依赖 另一个依赖被 tree-shaking 掉了怎么办， CSS 引用复杂，CSS 没打进去怎么办？
\- 微前端了解吗？
\- 为什么需要微前端？
\- 各种微前端的原理是什么？
\- JS 全局隔离怎么做？
\- 这种方法老版本兼容性不太好，有没有解决方案？
\- webpack 的联邦模块要先加载 container，在去取 remotes，有性能浪费，能不能直接将主应用和子应用（remotes）同时加载，应该怎么做？
\- B 端开发的时候有没有碰到什么问题、痛点？
\- 实习问题、怎么解决的？
\- 项目问，一个功能解决什么问题？
\- 鉴权为什么要存 token？
\- webworker 解决什么问题？
\- Token 和 cookie ssession 方案？
\- 这样会有什么安全问题？

js做数据循环用了哪些方法，如何实现的，这些方法哪种性能最好，哪种最不好
（我答的for最好，for...of最不好，也不知道对不对）
2、http2和http1.1的区别
3、axios库的原理
4、设计一个sdk实现前端发送的请求前加一个header，无论谁引用sdk，都会加header（偏场景题）
面试官给了一个aop埋点的思路
5、防抖和节流
6、vue双向绑定源码
7、promise常用的几种静态方法
8、react的jsx怎么转换成dom结构



美团（成都 到家事业群）前端面试记录

一面：
1 ts Partial
2 正则表达式匹配替换
3 Get是完全幂等的吗？
4 不适用js实现一个点击显示悬浮窗 active
5 webview上h5的屏幕适配
6 节流和防抖，应用场景
7 git代码出错标准处理
8 webpack打包优化和配置
9 babel和polyfill
10 盒模型 box-sizing
11 BFC
12 跨域和解决方案
13 dom操作 querySelectorAll（编程）
14 在Array原型链上添加flat()方法（编程）
15 驼峰命名转短横线命名（编程）

二面：
1 项目进度管理和质量保证
2 着重讲一下某个项目，遇到的具体难点是什么？
3 文件里面有一万个数，范围[0, 1000]，缓存大小只有2k，怎么实现排序及其优化？
4 节流函数（编程）
5 数组的左移右移实现（编程）
6 state变化到页面变化的整个过程



OPPO前端面试记录

1 为什么学习前端？
2 你对前端行业的认识？
3 Vue和React区别
4 Vue3和React16的新功能
5 前端性能优化策略
6 前端错误定位？
7 浏览器性能调试api？
8 事件循环
9 手机端h5适配方法？
10 尾递归

