---
title: 📣-防御实验
date: 2023-09-15 09:22:40
tags: ['防御实验', '持续更新中']
categories: 论文实验
---

{% raw %}

给全局模型参数加高斯噪声：$w{{_{G}^{r}}^{\prime }}=w_{G}^{r}+N(0,{{\sigma }^{2}})$，其中$\sigma =\sqrt{2\operatorname{In}\frac{1.25}{\delta }}\times \frac{\Delta f}{\epsilon }$，表示标准差，$\sigma^2$表示方差

$N(0,{{\sigma }^{2}})$表示从中心为 0 且方差为${\sigma }^{2}$的高斯（正态）分布中抽样。在实现的过程中，只需要给出方差的值即可。


问题1：如何设置高斯噪声的标准差？可以先设置为0.01

{% endraw %}

# 1.本地防御

## 1.频谱过滤（√）

### 1.设置参数

1.在cifar_fed.yaml中添加如下参数：

```yaml
# defence 这是自己写的
spectre_filter: True
 # 采样频率
f_sample: 1000
f_pass: 150
f_stop: 250
Ap: 1
As: 20
```

2.在parameter.py中添加如下代码：

```python
# defence
spectre_filter: bool = False
f_sample: int = None
f_pass: int = None
f_stop: int = None
Ap: int = None
As: int = None
```

### 2.设计低通滤波器

在atack.py中的compute_blind_loss加如下代码：

```python
# 自己的客户端防御
if self.params.spectre_filter:
    # 对每个图片进行DCT转换，并进行过滤操作
    batch_back = self.local_spectre(batch_back)
```

下面是local_spectre方法的实现过程：

```python
def local_spectre(self, batch):                                         # 本地频谱过滤
    # 先设计低通滤波器
    b0, a0 = self.lowpassFilter()
    # 转换图像，batch有batch.inputs[0]、batch.labels[0]
    filter_batch = batch.clone()
    # 将图像转换为灰度图像，并利用数字低通滤波器对图片进行滤波
    for i in range(self.params.batch_size):
        # 转为黑白图片
        gray_image = torch.mean(batch.inputs[i], dim=0)
        # 将NumPy数组复制以确保没有负步幅
        filter_img = signal.filtfilt(b0, a0, gray_image)
        filter_batch.inputs[i] = torch.from_numpy(np.copy(filter_img))
    print("------------------------已完成频谱过滤")
    sys.exit(1)
    return filter_batch
```

下面是低通滤波器的实现过程：

```python
# 低通滤波器设计
def lowpassFilter(self):
    # 设计巴特沃斯低通滤波器参数：先归一化，然后转换到模拟滤波器指标
    wp = 2 * self.params.f_pass / self.params.f_sample
    ws = 2 * self.params.f_stop / self.params.f_sample
    Wp = 2 * self.params.f_sample * np.tan(wp / 2)
    Ws = 2 * self.params.f_sample * np.tan(ws / 2)
    # 求滤波器的阶数和3db系数，为true表示模拟滤波器
    N, Wn = signal.buttord(Wp, Ws, self.params.Ap, self.params.As, analog=True)
    # 求低通滤波器的系数
    b, a = signal.butter(N, Wn, btype='low', analog=True)
    # 双线性转换为数字滤波器
    b0, a0 = signal.bilinear(b, a, fs=self.params.f_sample)
    return b0, a0
```

